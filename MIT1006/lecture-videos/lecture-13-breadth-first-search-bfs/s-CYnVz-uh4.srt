1
00:00:00,000 --> 00:00:00,050

2
00:00:00,050 --> 00:00:01,770
The following
content is provided

3
00:00:01,770 --> 00:00:04,010
under a Creative
Commons license.

4
00:00:04,010 --> 00:00:06,860
Your support will help MIT
OpenCourseWare continue

5
00:00:06,860 --> 00:00:10,720
to offer high quality
educational resources for free.

6
00:00:10,720 --> 00:00:13,330
To make a donation or
view additional materials

7
00:00:13,330 --> 00:00:17,226
from hundreds of MIT courses,
visit MIT OpenCourseWare

8
00:00:17,226 --> 00:00:17,851
at ocw.mit.edu.

9
00:00:17,851 --> 00:00:21,730

10
00:00:21,730 --> 00:00:23,980
PROFESSOR: Today we're going
to introduce graph search

11
00:00:23,980 --> 00:00:25,896
in general and talk about
one algorithm, which

12
00:00:25,896 --> 00:00:29,340
is breadth-first search, and
understand how in principle you

13
00:00:29,340 --> 00:00:33,180
can solve a puzzle
like the Rubik's Cube.

14
00:00:33,180 --> 00:00:37,990
So before I get to Rubik's
Cubes let me remind you

15
00:00:37,990 --> 00:00:41,942
of some basic
stuff about graphs.

16
00:00:41,942 --> 00:00:50,380
Or I can tell you to start
out with, graph search is

17
00:00:50,380 --> 00:00:52,905
about exploring a graph.

18
00:00:52,905 --> 00:00:55,890

19
00:00:55,890 --> 00:00:58,980
And there's many different
notions of exploring a graph.

20
00:00:58,980 --> 00:01:01,950
Maybe I give you some
node in a graph, s,

21
00:01:01,950 --> 00:01:03,790
and some other
node in a graph, t,

22
00:01:03,790 --> 00:01:06,940
and I'd like to
find a path that's

23
00:01:06,940 --> 00:01:09,390
going to represent a
problem like I give you

24
00:01:09,390 --> 00:01:13,140
a particular state of a
Rubik's Cube and I want to know

25
00:01:13,140 --> 00:01:16,534
is there some path that
gets me into a solved state?

26
00:01:16,534 --> 00:01:18,200
Do I really want to
solve this on stage?

27
00:01:18,200 --> 00:01:19,230
What the hell?

28
00:01:19,230 --> 00:01:21,650
We started.

29
00:01:21,650 --> 00:01:24,410
So this is a particularly
easy state to solve,

30
00:01:24,410 --> 00:01:26,816
which is why I set up this way.

31
00:01:26,816 --> 00:01:27,940
All right, so there you go.

32
00:01:27,940 --> 00:01:31,510
Seven by seven by seven Rubik's
Cube solved in 10 seconds.

33
00:01:31,510 --> 00:01:33,650
Amazing.

34
00:01:33,650 --> 00:01:36,030
New world record.

35
00:01:36,030 --> 00:01:39,327
So you're given some initial
state of the Rubik's Cube.

36
00:01:39,327 --> 00:01:40,702
You're given the
targets that you

37
00:01:40,702 --> 00:01:42,160
know what solved looks like.

38
00:01:42,160 --> 00:01:45,000
You want to find this path.

39
00:01:45,000 --> 00:01:47,887
Maybe you want to
find all paths from s.

40
00:01:47,887 --> 00:01:49,720
Maybe you just want to
explore all the nodes

41
00:01:49,720 --> 00:01:51,160
in a graph you can reach from s.

42
00:01:51,160 --> 00:01:53,460
Maybe you want to explore all
the nodes in a graph or maybe

43
00:01:53,460 --> 00:01:54,501
all the edges in a graph.

44
00:01:54,501 --> 00:01:56,077
These are all
exploration problems.

45
00:01:56,077 --> 00:01:57,910
They're all going to
be solved by algorithms

46
00:01:57,910 --> 00:02:01,640
from this class and next class.

47
00:02:01,640 --> 00:02:04,350
So before we go
further though, I

48
00:02:04,350 --> 00:02:07,740
should remind you what
a graph is and sort

49
00:02:07,740 --> 00:02:12,230
of basic features of graphs
that we're going to be using.

50
00:02:12,230 --> 00:02:15,390
This is also 6042 material so
you should know it very well.

51
00:02:15,390 --> 00:02:17,120
If you don't,
there's an appendix

52
00:02:17,120 --> 00:02:18,820
in the textbook about it.

53
00:02:18,820 --> 00:02:20,097
We have a set of vertices.

54
00:02:20,097 --> 00:02:21,055
We have a set of edges.

55
00:02:21,055 --> 00:02:33,360

56
00:02:33,360 --> 00:02:41,460
Edges are either
unordered pairs--

57
00:02:41,460 --> 00:02:50,630
some sets of two items--
or ordered pairs.

58
00:02:50,630 --> 00:02:58,230

59
00:02:58,230 --> 00:03:02,270
In this case, we call
the graph undirected.

60
00:03:02,270 --> 00:03:04,920
In this case, we call
the graph directed.

61
00:03:04,920 --> 00:03:07,630
Usually, there's only one type.

62
00:03:07,630 --> 00:03:09,030
Either all the
edges are directed

63
00:03:09,030 --> 00:03:11,690
or all the edges are undirected.

64
00:03:11,690 --> 00:03:13,440
There is a study of
graphs that have both,

65
00:03:13,440 --> 00:03:15,397
but we are not doing that here.

66
00:03:15,397 --> 00:03:18,720

67
00:03:18,720 --> 00:03:20,430
Some simple examples.

68
00:03:20,430 --> 00:03:23,344

69
00:03:23,344 --> 00:03:24,010
Here is a graph.

70
00:03:24,010 --> 00:03:29,570

71
00:03:29,570 --> 00:03:30,795
This is an undirected graph.

72
00:03:30,795 --> 00:03:42,820

73
00:03:42,820 --> 00:03:44,070
This is a directed graph.

74
00:03:44,070 --> 00:03:48,490

75
00:03:48,490 --> 00:03:50,115
The set of vertices
here is a, b, c, d.

76
00:03:50,115 --> 00:03:52,525
The set of vertices
here is a, b, c.

77
00:03:52,525 --> 00:03:56,990
The set of edges
here is-- E is going

78
00:03:56,990 --> 00:04:05,550
to be things like a, b; b, c;
c, d-- I think you get the idea.

79
00:04:05,550 --> 00:04:09,780

80
00:04:09,780 --> 00:04:12,750
Just for completeness,
V is a, b, c, d.

81
00:04:12,750 --> 00:04:14,640
Just so you remember
notations and so on.

82
00:04:14,640 --> 00:04:17,214

83
00:04:17,214 --> 00:04:19,589
One of the issues we're going
to talk about in this class

84
00:04:19,589 --> 00:04:23,562
is how do you represent a graph
like this for an algorithm?

85
00:04:23,562 --> 00:04:25,770
So it's all fine to say,
oh, this is a set of things.

86
00:04:25,770 --> 00:04:27,070
This is a set of things.

87
00:04:27,070 --> 00:04:28,490
An obvious
representation is, you

88
00:04:28,490 --> 00:04:31,120
have a list or an
array of vertices.

89
00:04:31,120 --> 00:04:32,520
You have an array of edges.

90
00:04:32,520 --> 00:04:34,320
Each edge knows
its two end points.

91
00:04:34,320 --> 00:04:37,650
That would be a horrible
representation for a graph

92
00:04:37,650 --> 00:04:39,920
because if you're, I
don't know, at vertex, a,

93
00:04:39,920 --> 00:04:42,340
and you want to know, well
what are the neighbors of a?

94
00:04:42,340 --> 00:04:43,260
b and c.

95
00:04:43,260 --> 00:04:45,290
You'd have to go through
the entire edge list

96
00:04:45,290 --> 00:04:47,380
to figure out the
neighbors of a.

97
00:04:47,380 --> 00:04:50,424
So it's been linear time just
to know where you can go from a.

98
00:04:50,424 --> 00:04:52,340
So we're not going to
use that representation.

99
00:04:52,340 --> 00:04:55,430
We're going to use some
better representations.

100
00:04:55,430 --> 00:04:57,160
Something called
an adjacency list.

101
00:04:57,160 --> 00:05:01,560

102
00:05:01,560 --> 00:05:07,970
Over here, you've got things
like a, c; b, c; and c, b.

103
00:05:07,970 --> 00:05:10,716
So you can have edges
in both directions.

104
00:05:10,716 --> 00:05:11,620
What am I missing?

105
00:05:11,620 --> 00:05:12,120
b, a.

106
00:05:12,120 --> 00:05:14,892

107
00:05:14,892 --> 00:05:17,480
So that's E, in that case.

108
00:05:17,480 --> 00:05:22,180

109
00:05:22,180 --> 00:05:25,484
There are a whole lot of
applications of graph search.

110
00:05:25,484 --> 00:05:28,430
I'll make you a little list
to talk about few of them.

111
00:05:28,430 --> 00:05:32,270

112
00:05:32,270 --> 00:05:35,095
So we've got web crawling.

113
00:05:35,095 --> 00:05:39,010

114
00:05:39,010 --> 00:05:39,605
You're Google.

115
00:05:39,605 --> 00:05:42,100
You want to find all
the pages on the web.

116
00:05:42,100 --> 00:05:45,050
Most people don't just tell
you, hey, I've got a new page,

117
00:05:45,050 --> 00:05:46,450
please index it.

118
00:05:46,450 --> 00:05:48,274
You have to just keep
following links--

119
00:05:48,274 --> 00:05:49,690
in the early days
of the web, this

120
00:05:49,690 --> 00:05:51,920
was a big deal--
following links finding

121
00:05:51,920 --> 00:05:53,659
everything that's out there.

122
00:05:53,659 --> 00:05:56,200
It's a little bit of an issue
because if you define it wrong,

123
00:05:56,200 --> 00:05:59,690
the internet is infinite
because of all those dynamically

124
00:05:59,690 --> 00:06:00,600
generated pages.

125
00:06:00,600 --> 00:06:03,330
But to deal with
that, Google goes

126
00:06:03,330 --> 00:06:05,350
sort of breadth-first
for the most part.

127
00:06:05,350 --> 00:06:09,710
It's prioritized You want
to see all the things you

128
00:06:09,710 --> 00:06:15,440
can reach from pages you
already have and keep going.

129
00:06:15,440 --> 00:06:19,130
At some point, you give up
when you run out of time.

130
00:06:19,130 --> 00:06:21,130
Social networking.

131
00:06:21,130 --> 00:06:22,000
You're on Facebook.

132
00:06:22,000 --> 00:06:23,500
You use Friend Finder.

133
00:06:23,500 --> 00:06:26,260
It tries to find the friends
that are nearest to you.

134
00:06:26,260 --> 00:06:31,140
Or friends of friends is
sort of a level to search.

135
00:06:31,140 --> 00:06:33,340
That's essentially a
graph search problem.

136
00:06:33,340 --> 00:06:37,130
You want to know what's
two levels or three

137
00:06:37,130 --> 00:06:39,180
levels of separation from you.

138
00:06:39,180 --> 00:06:43,529
And then you loop over those
and look for other signs

139
00:06:43,529 --> 00:06:44,820
that you might be good friends.

140
00:06:44,820 --> 00:06:49,560

141
00:06:49,560 --> 00:06:54,460
You are on a network like the
internet or some intranet.

142
00:06:54,460 --> 00:06:56,110
You want to broadcast a message.

143
00:06:56,110 --> 00:06:57,340
So here's you.

144
00:06:57,340 --> 00:06:59,350
You want to send data out.

145
00:06:59,350 --> 00:07:01,830
That's essentially a
graph exploration problem.

146
00:07:01,830 --> 00:07:04,850
That message, that packet, is
going to explore the graph.

147
00:07:04,850 --> 00:07:09,460

148
00:07:09,460 --> 00:07:10,325
Garbage collection.

149
00:07:10,325 --> 00:07:14,340

150
00:07:14,340 --> 00:07:17,369
I hope you all know that
modern languages have

151
00:07:17,369 --> 00:07:18,160
garbage collection.

152
00:07:18,160 --> 00:07:21,740
This is why you don't have to
worry about freeing things.

153
00:07:21,740 --> 00:07:23,800
Even in Python--
even in CPython,

154
00:07:23,800 --> 00:07:27,600
I learned-- there is a garbage
collector as of version two.

155
00:07:27,600 --> 00:07:32,070
But also in PyPy, and JPython
and in Java-- pretty much

156
00:07:32,070 --> 00:07:36,730
every fairly modern language
you have garbage collection.

157
00:07:36,730 --> 00:07:40,900
Meaning, if there's some data
that's unreachable from-- So

158
00:07:40,900 --> 00:07:43,820
you have your variables.

159
00:07:43,820 --> 00:07:45,890
Variables that can be
accessed by the program.

160
00:07:45,890 --> 00:07:48,410
Everything that's reachable
from there you have to keep.

161
00:07:48,410 --> 00:07:52,020
But if some data structure
becomes no longer reachable,

162
00:07:52,020 --> 00:07:57,895
you can throw it away
and regain memory.

163
00:07:57,895 --> 00:08:00,020
So that's happening behind
the scenes all the time,

164
00:08:00,020 --> 00:08:01,750
and the way it's
being done is with

165
00:08:01,750 --> 00:08:03,170
their breadth-first
search, which

166
00:08:03,170 --> 00:08:04,990
is what we're going
to talk about today.

167
00:08:04,990 --> 00:08:07,620

168
00:08:07,620 --> 00:08:08,450
Another one.

169
00:08:08,450 --> 00:08:09,095
Model checking.

170
00:08:09,095 --> 00:08:14,890

171
00:08:14,890 --> 00:08:21,250
Model checking is-- you have
some finite model of either

172
00:08:21,250 --> 00:08:24,205
a piece of code, or a
circuit, or chip, whatever,

173
00:08:24,205 --> 00:08:26,220
and you want to prove
that it actually

174
00:08:26,220 --> 00:08:27,620
does what you think it does.

175
00:08:27,620 --> 00:08:29,530
And so you've drawn a graph.

176
00:08:29,530 --> 00:08:31,790
The graph is all
the possible states

177
00:08:31,790 --> 00:08:36,000
that your circuit or your
computer program could reach,

178
00:08:36,000 --> 00:08:38,393
or that it could possibly have.

179
00:08:38,393 --> 00:08:40,059
You start in some
initial state, and you

180
00:08:40,059 --> 00:08:42,267
want to know among all the
states that you can reach,

181
00:08:42,267 --> 00:08:43,400
does it have some property.

182
00:08:43,400 --> 00:08:46,050
And so you need to visit
all the vertices that

183
00:08:46,050 --> 00:08:48,500
are reachable from
a particular place.

184
00:08:48,500 --> 00:08:53,720
And usually people do that
using breadth-first search.

185
00:08:53,720 --> 00:08:55,390
I use breadth-first
search a lot,

186
00:08:55,390 --> 00:08:59,860
myself, to check
mathematical conjectures.

187
00:08:59,860 --> 00:09:06,270
So if you're a mathematician,
and you think something

188
00:09:06,270 --> 00:09:07,722
is true.

189
00:09:07,722 --> 00:09:11,600
Like maybe-- It's hard to
give an example of that.

190
00:09:11,600 --> 00:09:15,690
But you can imagine some graph
of all the possible inputs

191
00:09:15,690 --> 00:09:17,700
to that theorem, and
you need to check

192
00:09:17,700 --> 00:09:20,379
them for every possible
input-- If this is true--

193
00:09:20,379 --> 00:09:22,170
the typical way to do
that is breadth-first

194
00:09:22,170 --> 00:09:27,100
searching through that
entire graph of states.

195
00:09:27,100 --> 00:09:29,694
Usually, we're testing
finite, special cases

196
00:09:29,694 --> 00:09:32,110
of a general conjecture, but
if we find a counter-example,

197
00:09:32,110 --> 00:09:32,900
we're done.

198
00:09:32,900 --> 00:09:34,591
Don't have to work
on it anymore.

199
00:09:34,591 --> 00:09:36,590
If we don't find a
counter-example, usually then

200
00:09:36,590 --> 00:09:38,270
we have to do the mathematics.

201
00:09:38,270 --> 00:09:42,695
It doesn't solve everything,
but it's helpful.

202
00:09:42,695 --> 00:09:47,600

203
00:09:47,600 --> 00:09:52,430
And then, the fun
thing we're going

204
00:09:52,430 --> 00:09:54,070
to talk about a
little bit today,

205
00:09:54,070 --> 00:09:55,903
is if you want to solve
something like a two

206
00:09:55,903 --> 00:09:57,939
by two by two Rubik's
Cube optimally,

207
00:09:57,939 --> 00:09:59,730
you can do that using
breadth-first search.

208
00:09:59,730 --> 00:10:02,935
And you're going to do
that on your problem set.

209
00:10:02,935 --> 00:10:04,850
To do it solving
this one optimally

210
00:10:04,850 --> 00:10:09,560
using breadth-first search would
probably-- would definitely--

211
00:10:09,560 --> 00:10:12,330
take more than the
lifetime of the universe.

212
00:10:12,330 --> 00:10:14,780
So don't try seven
by seven by seven.

213
00:10:14,780 --> 00:10:17,610

214
00:10:17,610 --> 00:10:21,180
Leave that to the
cubing experts, I guess.

215
00:10:21,180 --> 00:10:23,610
I think no one will ever solve
a seven by seven by seven

216
00:10:23,610 --> 00:10:26,150
Rubik's Cube optimally.

217
00:10:26,150 --> 00:10:30,190
There are ways to find a
solution just not the best one.

218
00:10:30,190 --> 00:10:33,395
So let me tell you just
for fun, as an example.

219
00:10:33,395 --> 00:10:36,930

220
00:10:36,930 --> 00:10:41,530
This Pocket Cube, which is a
two by two by two Rubik's Cube.

221
00:10:41,530 --> 00:10:45,780
What we have in mind is
called the configuration graph

222
00:10:45,780 --> 00:10:48,480
or sometimes
configuration space.

223
00:10:48,480 --> 00:10:50,701
But it's a graph, so
we'll call it a graph.

224
00:10:50,701 --> 00:10:54,040

225
00:10:54,040 --> 00:11:01,465
This graph has a vertex for
each possible state of the cube.

226
00:11:01,465 --> 00:11:10,340

227
00:11:10,340 --> 00:11:12,535
So this is a state.

228
00:11:12,535 --> 00:11:15,140

229
00:11:15,140 --> 00:11:16,820
This is a state.

230
00:11:16,820 --> 00:11:17,640
This is a state.

231
00:11:17,640 --> 00:11:19,240
This is a state.

232
00:11:19,240 --> 00:11:21,790
Now I'm hopelessly lost.

233
00:11:21,790 --> 00:11:23,540
Anyone want to work on this?

234
00:11:23,540 --> 00:11:25,802
Bored?

235
00:11:25,802 --> 00:11:26,560
No one?

236
00:11:26,560 --> 00:11:28,510
Alright, I'll leave
it unsolved then.

237
00:11:28,510 --> 00:11:31,040

238
00:11:31,040 --> 00:11:32,522
So all those are vertices.

239
00:11:32,522 --> 00:11:33,980
There's actually
a lot of vertices.

240
00:11:33,980 --> 00:11:38,690
There are 264 million
vertices or so.

241
00:11:38,690 --> 00:11:39,310
If you want.

242
00:11:39,310 --> 00:11:41,560
To the side here.

243
00:11:41,560 --> 00:11:49,300
Number of vertices is something
like 8 factorial times 3

244
00:11:49,300 --> 00:11:51,950
to the 8.

245
00:11:51,950 --> 00:11:57,637
And one way to see that
is to draw a two by two

246
00:11:57,637 --> 00:11:58,470
by two Rubik's Cube.

247
00:11:58,470 --> 00:12:01,458

248
00:12:01,458 --> 00:12:12,890
So these are what you
might call cubelets,

249
00:12:12,890 --> 00:12:16,370
or cubies I think is the
standard term in Rubik's Cube

250
00:12:16,370 --> 00:12:16,870
land.

251
00:12:16,870 --> 00:12:21,220

252
00:12:21,220 --> 00:12:23,125
There's eight of them
in a two by two by two.

253
00:12:23,125 --> 00:12:24,750
Two cubed.

254
00:12:24,750 --> 00:12:28,452
You can essentially permute
those cubies within the cube

255
00:12:28,452 --> 00:12:29,160
however you like.

256
00:12:29,160 --> 00:12:31,020
That's 8 factorial.

257
00:12:31,020 --> 00:12:33,234
And then each of them has
three possible twists.

258
00:12:33,234 --> 00:12:34,150
It could be like this.

259
00:12:34,150 --> 00:12:35,180
It could be like this.

260
00:12:35,180 --> 00:12:37,700
Or it could be like this.

261
00:12:37,700 --> 00:12:39,356
So you've got three for each.

262
00:12:39,356 --> 00:12:40,980
And this is actually
an accurate count.

263
00:12:40,980 --> 00:12:43,229
You're not over-counting the
number of configurations.

264
00:12:43,229 --> 00:12:45,760
All of those are, at least
in principle, conceivable.

265
00:12:45,760 --> 00:12:48,060
If you take apart the
cube, you can reassemble it

266
00:12:48,060 --> 00:12:49,590
in each of those states.

267
00:12:49,590 --> 00:12:53,930
And that number is
about 264 million.

268
00:12:53,930 --> 00:12:57,720

269
00:12:57,720 --> 00:13:00,000
Which is not so
bad for computers.

270
00:13:00,000 --> 00:13:01,764
You could search that.

271
00:13:01,764 --> 00:13:02,930
Life is a little bit easier.

272
00:13:02,930 --> 00:13:04,940
You get to divide by
24 because there's

273
00:13:04,940 --> 00:13:06,800
24 symmetries of the cube.

274
00:13:06,800 --> 00:13:08,190
Eight times three.

275
00:13:08,190 --> 00:13:12,329
You can divide by three,
also, because only a third

276
00:13:12,329 --> 00:13:14,370
of the configuration space
is actually reachable.

277
00:13:14,370 --> 00:13:16,070
If you're not allowed
to take the parts apart,

278
00:13:16,070 --> 00:13:17,720
if you have to get
there by a motion,

279
00:13:17,720 --> 00:13:21,096
you can only get to 1/3
of the two by two by two.

280
00:13:21,096 --> 00:13:22,720
So it's a little bit
smaller than that,

281
00:13:22,720 --> 00:13:24,550
if you're actually doing a
breadth-first search, which

282
00:13:24,550 --> 00:13:26,758
is what you're going to be
doing on your problem set.

283
00:13:26,758 --> 00:13:29,350
But in any case, it's feasible.

284
00:13:29,350 --> 00:13:30,370
That was vertices.

285
00:13:30,370 --> 00:13:31,575
We should talk about edges.

286
00:13:31,575 --> 00:13:42,240

287
00:13:42,240 --> 00:13:47,570
For every move--
every move takes you

288
00:13:47,570 --> 00:13:49,870
from one configuration
to another.

289
00:13:49,870 --> 00:13:52,960
You could traverse it in one
direction and make that move.

290
00:13:52,960 --> 00:13:54,210
You could also undo that move.

291
00:13:54,210 --> 00:13:57,230
Because every move is
undoable in a Rubik's Cube,

292
00:13:57,230 --> 00:13:58,940
this graph is undirected.

293
00:13:58,940 --> 00:14:02,570
Or you can think of it as every
edge works in both directions.

294
00:14:02,570 --> 00:14:03,610
So this is a move.

295
00:14:03,610 --> 00:14:05,830
It's called a quarter twist.

296
00:14:05,830 --> 00:14:07,640
This is a controversy
if you will.

297
00:14:07,640 --> 00:14:10,430
Some people allow a whole
half twist as a single move.

298
00:14:10,430 --> 00:14:13,030
Whether you define that as a
single move or a double move

299
00:14:13,030 --> 00:14:14,380
is not that big a deal.

300
00:14:14,380 --> 00:14:17,920
It just changes
some of the answers.

301
00:14:17,920 --> 00:14:20,970
But you're still exploring
essentially the same graph.

302
00:14:20,970 --> 00:14:23,454

303
00:14:23,454 --> 00:14:24,870
So that's the graph
and you'd like

304
00:14:24,870 --> 00:14:26,244
to know some
properties about it.

305
00:14:26,244 --> 00:14:28,580
So let me draw a
picture of the graph.

306
00:14:28,580 --> 00:14:31,560
I'm not going to draw
all 264 million vertices.

307
00:14:31,560 --> 00:14:34,960
But in particular,
there's the solved state--

308
00:14:34,960 --> 00:14:38,100
we kind of care about that
one, where all the colors are

309
00:14:38,100 --> 00:14:44,390
aligned-- then there's all of
the configurations you could

310
00:14:44,390 --> 00:14:46,040
reach by one move.

311
00:14:46,040 --> 00:14:49,950
So these are the possible
moves from the solved state.

312
00:14:49,950 --> 00:14:52,950

313
00:14:52,950 --> 00:14:55,400
And then from those
configurations,

314
00:14:55,400 --> 00:14:57,970
there's more places you can go.

315
00:14:57,970 --> 00:15:00,448
Maybe there's multiple ways
to get to the same node.

316
00:15:00,448 --> 00:15:03,320

317
00:15:03,320 --> 00:15:05,250
But these would be
all the configurations

318
00:15:05,250 --> 00:15:07,190
you can reach in two moves.

319
00:15:07,190 --> 00:15:15,170

320
00:15:15,170 --> 00:15:16,940
And so on.

321
00:15:16,940 --> 00:15:19,100
And at some point,
you run out of graph.

322
00:15:19,100 --> 00:15:26,250
So there might be a
few nodes out here.

323
00:15:26,250 --> 00:15:28,580
The way I'm drawing
this, this is everything

324
00:15:28,580 --> 00:15:31,240
you can reach in one move, in
two movies, in three moves.

325
00:15:31,240 --> 00:15:35,010
At the end, this
would be 11 moves,

326
00:15:35,010 --> 00:15:37,760
if you allow half twists.

327
00:15:37,760 --> 00:15:41,470
And as puzzlers,
we're particularly

328
00:15:41,470 --> 00:15:47,020
interested in this number,
which you would call, as a graph

329
00:15:47,020 --> 00:15:50,760
theorist, the
diameter of the graph.

330
00:15:50,760 --> 00:15:53,200
Puzzlers call it God's number.

331
00:15:53,200 --> 00:15:59,020
If you were God or some
omni-- something being.

332
00:15:59,020 --> 00:16:01,860
You have the optimal algorithm
for solving the Rubik's Cube.

333
00:16:01,860 --> 00:16:04,220
How many moves do you
need If you always

334
00:16:04,220 --> 00:16:06,100
follow the best path?

335
00:16:06,100 --> 00:16:08,650
And the answer is, in
the worst case, 11.

336
00:16:08,650 --> 00:16:14,130
So we're interested in the worst
case of the best algorithm.

337
00:16:14,130 --> 00:16:16,880
For two by two by
two, the answer is 11.

338
00:16:16,880 --> 00:16:20,050
For three by three by
three, the answer is 20.

339
00:16:20,050 --> 00:16:23,070
That was just proved
last summer with a couple

340
00:16:23,070 --> 00:16:24,650
years of computer time.

341
00:16:24,650 --> 00:16:26,734
For four by four by four--
I don't have one here--

342
00:16:26,734 --> 00:16:28,233
I think we'll never
know the answer.

343
00:16:28,233 --> 00:16:30,525
For five by five by five,
we'll never know the answer.

344
00:16:30,525 --> 00:16:33,820
For six, for seven, same deal.

345
00:16:33,820 --> 00:16:36,330
But for two by two by
two, you can compute it.

346
00:16:36,330 --> 00:16:38,180
You will compute it
on your problem set.

347
00:16:38,180 --> 00:16:42,010
And it's kind of nice to
know because it says whatever

348
00:16:42,010 --> 00:16:46,800
configuration I'm in, I
can solve it in 11 moves.

349
00:16:46,800 --> 00:16:49,440
But the best known
way to compute it,

350
00:16:49,440 --> 00:16:54,220
is basically to construct
this graph one layer at a time

351
00:16:54,220 --> 00:16:55,470
until you're done.

352
00:16:55,470 --> 00:16:57,310
And then you know
what the diameter is.

353
00:16:57,310 --> 00:17:00,910
The trouble is, in between
here this grows exponentially.

354
00:17:00,910 --> 00:17:03,180
At some point, it
decreases a little bit.

355
00:17:03,180 --> 00:17:04,970
But getting over
that exponential hump

356
00:17:04,970 --> 00:17:06,564
is really hard.

357
00:17:06,564 --> 00:17:08,980
And for three by three by
three, they used a lot of tricks

358
00:17:08,980 --> 00:17:13,490
to speed up the
algorithm, but in the end

359
00:17:13,490 --> 00:17:15,760
it's essentially a
breadth-first search.

360
00:17:15,760 --> 00:17:17,359
What's a breadth-first search?

361
00:17:17,359 --> 00:17:19,060
This going layer by layer.

362
00:17:19,060 --> 00:17:22,430
So we're going to
formalize that in a moment.

363
00:17:22,430 --> 00:17:25,089
But that is the problem.

364
00:17:25,089 --> 00:17:37,920
So just for fun, any guesses
what the right answer

365
00:17:37,920 --> 00:17:40,020
is for an n by n
by n Rubik's cube?

366
00:17:40,020 --> 00:17:41,880
What's the diameter?

367
00:17:41,880 --> 00:17:43,380
Not an exact answer,
because I think

368
00:17:43,380 --> 00:17:44,850
we'll never know
the exact answer.

369
00:17:44,850 --> 00:17:48,558
But if I want theta
something, what

370
00:17:48,558 --> 00:17:50,280
do you think the something is?

371
00:17:50,280 --> 00:17:54,649

372
00:17:54,649 --> 00:17:56,732
How many people here have
solved the Rubik's Cube?

373
00:17:56,732 --> 00:17:58,130
Ever?

374
00:17:58,130 --> 00:18:00,510
So you know what we're
talking about here.

375
00:18:00,510 --> 00:18:04,390
Most people have worked on it.

376
00:18:04,390 --> 00:18:08,280
To think about an n by
n by n Rubik's Cube,

377
00:18:08,280 --> 00:18:11,420
each side has area n squared.

378
00:18:11,420 --> 00:18:14,210
So total surface
area is 6 n squared.

379
00:18:14,210 --> 00:18:18,718
So there's, roughly, stata n
squared little cubies here.

380
00:18:18,718 --> 00:18:21,301
So what do you think the right
[INAUDIBLE] is for n by n by n?

381
00:18:21,301 --> 00:18:26,702

382
00:18:26,702 --> 00:18:27,480
No guesses?

383
00:18:27,480 --> 00:18:32,095

384
00:18:32,095 --> 00:18:33,450
AUDIENCE: n cubed?

385
00:18:33,450 --> 00:18:34,900
PROFESSOR: n cubed?

386
00:18:34,900 --> 00:18:36,540
Reasonable guess.

387
00:18:36,540 --> 00:18:38,045
But wrong.

388
00:18:38,045 --> 00:18:39,690
It's an upper bounds.

389
00:18:39,690 --> 00:18:40,890
Why n cubed?

390
00:18:40,890 --> 00:18:43,432

391
00:18:43,432 --> 00:18:44,348
AUDIENCE: [INAUDIBLE].

392
00:18:44,348 --> 00:18:48,834

393
00:18:48,834 --> 00:18:51,000
PROFESSOR: Oh, you're
guessing based on the numbers.

394
00:18:51,000 --> 00:18:51,499
Yeah.

395
00:18:51,499 --> 00:18:53,500
The numbers are
misleading, unfortunately.

396
00:18:53,500 --> 00:18:56,466
It's the law of small
numbers I guess.

397
00:18:56,466 --> 00:18:59,300
It doesn't really look right.

398
00:18:59,300 --> 00:19:00,636
I know the answer.

399
00:19:00,636 --> 00:19:02,010
I know the answer
because we just

400
00:19:02,010 --> 00:19:03,259
wrote a paper with the answer.

401
00:19:03,259 --> 00:19:04,490
This is a new result.

402
00:19:04,490 --> 00:19:05,940
From this summer.

403
00:19:05,940 --> 00:19:08,330
But I'm curious.

404
00:19:08,330 --> 00:19:10,410
To me the obvious
answer is n squared

405
00:19:10,410 --> 00:19:12,700
because there's about
n squared cubies.

406
00:19:12,700 --> 00:19:15,340
And it's not so hard to show
in a constant number moves

407
00:19:15,340 --> 00:19:19,011
you can solve a constant
number of cubies.

408
00:19:19,011 --> 00:19:20,760
If you think about the
general algorithms,

409
00:19:20,760 --> 00:19:22,676
like if you've ever
looked up professor's cube

410
00:19:22,676 --> 00:19:25,200
and how to solve it,
you're doing like 10 moves,

411
00:19:25,200 --> 00:19:27,720
and then maybe you
swap two cubies

412
00:19:27,720 --> 00:19:30,530
which you can use to
solve a couple of cubies

413
00:19:30,530 --> 00:19:31,910
in a constant number of moves.

414
00:19:31,910 --> 00:19:36,400
So n squared would be
the standard answer

415
00:19:36,400 --> 00:19:38,600
if you're following
standard algorithms.

416
00:19:38,600 --> 00:19:41,225
But it turns out, you can
do a little bit better.

417
00:19:41,225 --> 00:19:43,350
And the right answer is n
squared divided by log n.

418
00:19:43,350 --> 00:19:45,050
I think it's cool.

419
00:19:45,050 --> 00:19:46,814
Hopefully, you guys
can appreciate that.

420
00:19:46,814 --> 00:19:48,980
Not a lot of people can
appreciate n squared divided

421
00:19:48,980 --> 00:19:52,365
by log n, but here in
algorithms, we're all about n

422
00:19:52,365 --> 00:19:53,290
squared over log n.

423
00:19:53,290 --> 00:19:57,770

424
00:19:57,770 --> 00:20:00,420
If you're interested, the
paper's on my website.

425
00:20:00,420 --> 00:20:03,590
I think its called, Algorithms
For Solving Rubik's Cubes.

426
00:20:03,590 --> 00:20:05,110
There's a constant there.

427
00:20:05,110 --> 00:20:06,980
Current constant is not so good.

428
00:20:06,980 --> 00:20:08,320
Let's say it's in the millions.

429
00:20:08,320 --> 00:20:11,760
[LAUGHTER]

430
00:20:11,760 --> 00:20:13,010
You've got to start somewhere.

431
00:20:13,010 --> 00:20:15,754

432
00:20:15,754 --> 00:20:17,420
The next open problem
will be to improve

433
00:20:17,420 --> 00:20:19,170
that constant to
something reasonable that

434
00:20:19,170 --> 00:20:20,720
maybe is close to 20.

435
00:20:20,720 --> 00:20:25,250
But we're far from that.

436
00:20:25,250 --> 00:20:27,145
Let's talk about
graph representation.

437
00:20:27,145 --> 00:20:31,289

438
00:20:31,289 --> 00:20:33,080
Before we can talk
about exporting a graph,

439
00:20:33,080 --> 00:20:36,680
we need to know what
we're given as input.

440
00:20:36,680 --> 00:20:39,950
And there's basically one
standard representation

441
00:20:39,950 --> 00:20:43,510
and a bunch of variations of it.

442
00:20:43,510 --> 00:20:45,125
And they're called
adjacency lists.

443
00:20:45,125 --> 00:20:48,090

444
00:20:48,090 --> 00:20:49,720
So the idea with
an adjacency list,

445
00:20:49,720 --> 00:20:58,436
is you have an array
called Adj, for adjacency

446
00:20:58,436 --> 00:21:02,290
of size V. Each
element in the array

447
00:21:02,290 --> 00:21:03,735
is a pointer to a linked list.

448
00:21:03,735 --> 00:21:07,610

449
00:21:07,610 --> 00:21:12,260
And the idea is that this
array is indexed by a vertex.

450
00:21:12,260 --> 00:21:18,960

451
00:21:18,960 --> 00:21:21,170
So we're imagining
a world where we

452
00:21:21,170 --> 00:21:23,500
can index arrays by vertices.

453
00:21:23,500 --> 00:21:25,960
So maybe, you just
label your vertices

454
00:21:25,960 --> 00:21:27,730
zero through v minus 1.

455
00:21:27,730 --> 00:21:29,760
Then that's a regular array.

456
00:21:29,760 --> 00:21:31,802
Or, if you want
to get fancy, you

457
00:21:31,802 --> 00:21:35,200
can think of a vertex as an
arbitrary hashable thing,

458
00:21:35,200 --> 00:21:37,700
and Adj is actually
a hash table.

459
00:21:37,700 --> 00:21:39,810
And that's how you
probably do it in Python.

460
00:21:39,810 --> 00:21:42,910
Maybe your vertices are
objects, and this is just

461
00:21:42,910 --> 00:21:44,764
hashing based on the
address of the object.

462
00:21:44,764 --> 00:21:46,430
But we're not going
to worry about that.

463
00:21:46,430 --> 00:21:48,370
We're just going
to write Adj of u.

464
00:21:48,370 --> 00:21:50,560
Assume that somehow you
can get to the linked list

465
00:21:50,560 --> 00:21:51,768
corresponding to that vertex.

466
00:21:51,768 --> 00:22:00,680

467
00:22:00,680 --> 00:22:02,420
And the idea is,
for every vertex

468
00:22:02,420 --> 00:22:06,260
we just store its
neighbors, namely

469
00:22:06,260 --> 00:22:10,220
the vertices you can
reach by one step from u.

470
00:22:10,220 --> 00:22:13,150
So I'm going to define that
a little more formally.

471
00:22:13,150 --> 00:22:17,080
Adj of u is going to be
the set of all vertices,

472
00:22:17,080 --> 00:22:22,430
V, such that u, v is an edge.

473
00:22:22,430 --> 00:22:31,320

474
00:22:31,320 --> 00:22:35,990
So if I have a vertex
like b, Adj of b

475
00:22:35,990 --> 00:22:38,685
is going to be both a
and c because in one step

476
00:22:38,685 --> 00:22:42,010
there are outgoing edges
from b to a and b to c.

477
00:22:42,010 --> 00:22:44,730
So Adj of b is a, c.

478
00:22:44,730 --> 00:22:52,260

479
00:22:52,260 --> 00:22:53,530
In that graph.

480
00:22:53,530 --> 00:22:56,620
I should have labeled the
vertices something different.

481
00:22:56,620 --> 00:23:02,310
Adj of a is going to
be just c because you

482
00:23:02,310 --> 00:23:05,145
can't get with one
step from a to b.

483
00:23:05,145 --> 00:23:08,080
The edge is in the
wrong direction.

484
00:23:08,080 --> 00:23:13,240
And Adj of c is b.

485
00:23:13,240 --> 00:23:17,480

486
00:23:17,480 --> 00:23:19,260
I think that definition's
pretty clear.

487
00:23:19,260 --> 00:23:23,290
For undirected graphs,
you just put braces here.

488
00:23:23,290 --> 00:23:25,980
Which means you store-- I
mean, it's the same thing.

489
00:23:25,980 --> 00:23:29,180
Here Adj of c is going
to be a, b, and d, as you

490
00:23:29,180 --> 00:23:33,200
can get in one step from c to
a, from c to b, from c to d.

491
00:23:33,200 --> 00:23:36,700
For pretty much every-- At least
for graph exploration problems,

492
00:23:36,700 --> 00:23:38,580
this is the
representation you want.

493
00:23:38,580 --> 00:23:39,850
Because you're at some
vertex, and you want to know,

494
00:23:39,850 --> 00:23:40,930
where can I go next.

495
00:23:40,930 --> 00:23:44,560
And Adj of that vertex tells you
exactly where you can go next.

496
00:23:44,560 --> 00:23:45,830
So this is what you want.

497
00:23:45,830 --> 00:23:50,030

498
00:23:50,030 --> 00:23:53,040
There's a lot of different
ways to actually implement

499
00:23:53,040 --> 00:23:56,540
adjacency lists.

500
00:23:56,540 --> 00:23:59,440
I've talked about two of them.

501
00:23:59,440 --> 00:24:02,720
You could have the vertices
labeled zero to v minus 1,

502
00:24:02,720 --> 00:24:05,020
and then this is,
literally, an array.

503
00:24:05,020 --> 00:24:08,460
And you have-- I
guess I should draw.

504
00:24:08,460 --> 00:24:13,730
In this picture,
Adj is an array.

505
00:24:13,730 --> 00:24:17,080
So you've got a, b, and c.

506
00:24:17,080 --> 00:24:20,490
Each one of them is a
pointer to a linked list.

507
00:24:20,490 --> 00:24:27,510
This one's actually going
to be a, c, and we're done.

508
00:24:27,510 --> 00:24:30,820
Sorry, that was b.

509
00:24:30,820 --> 00:24:33,520
Who said it had to be
alphabetical order?

510
00:24:33,520 --> 00:24:38,110
A is a pointer to c,
c is a pointer to b.

511
00:24:38,110 --> 00:24:40,570
That's explicitly how
you might represent it.

512
00:24:40,570 --> 00:24:43,350
This might be a hash
table instead of an array,

513
00:24:43,350 --> 00:24:45,870
if you have weirder vertices.

514
00:24:45,870 --> 00:24:48,370
You can also do it in a more
object-oriented fashion.

515
00:24:48,370 --> 00:24:55,590

516
00:24:55,590 --> 00:24:59,090
For every vertex, v, you can
make the vertices objects,

517
00:24:59,090 --> 00:25:05,930
and v dot neighbors
could store what

518
00:25:05,930 --> 00:25:08,460
we're defining over
there to be Adj

519
00:25:08,460 --> 00:25:13,630
of v. This would be the more
object-oriented way to do it

520
00:25:13,630 --> 00:25:16,040
I've thought a lot about
this, and I like this,

521
00:25:16,040 --> 00:25:19,010
and usually when I implement
graphs this is what I do.

522
00:25:19,010 --> 00:25:23,200
But it is actually convenient
to have this representation.

523
00:25:23,200 --> 00:25:25,665
There's a reason the textbook
uses this representation.

524
00:25:25,665 --> 00:25:28,040
Because, if you've already
got some vertices lying around

525
00:25:28,040 --> 00:25:31,150
and you want to have multiple
graphs on those vertices,

526
00:25:31,150 --> 00:25:33,710
this lets you do that.

527
00:25:33,710 --> 00:25:37,934
You can define multiple Adj
arrays, one for graph one, one

528
00:25:37,934 --> 00:25:39,350
for graph two, one
for graph three

529
00:25:39,350 --> 00:25:41,790
but they can all talk
about the same vertices.

530
00:25:41,790 --> 00:25:45,410
Whereas here, vertex can
only belong to one graph.

531
00:25:45,410 --> 00:25:48,260
It can only have one
neighbor structure

532
00:25:48,260 --> 00:25:49,390
that says what happens.

533
00:25:49,390 --> 00:25:51,000
If you're only dealing
with one graph,

534
00:25:51,000 --> 00:25:52,850
this is probably cleaner.

535
00:25:52,850 --> 00:25:56,220
But with multiple graphs, which
will happen even in this class,

536
00:25:56,220 --> 00:26:00,534
adjacency lists are
kind of the way to go.

537
00:26:00,534 --> 00:26:02,450
You can also do
implicitly-represented graphs.

538
00:26:02,450 --> 00:26:13,580

539
00:26:13,580 --> 00:26:20,595
Which would be to say,
Adj of u is a function.

540
00:26:20,595 --> 00:26:23,960

541
00:26:23,960 --> 00:26:36,660
Or v dot neighbors is a
method of the vertex class.

542
00:26:36,660 --> 00:26:39,210
Meaning, it's not just
stored there explicitly.

543
00:26:39,210 --> 00:26:41,270
Whenever you need it,
you call this function

544
00:26:41,270 --> 00:26:45,500
and it computes what you want.

545
00:26:45,500 --> 00:26:47,420
This is useful because
it uses less space.

546
00:26:47,420 --> 00:26:52,030
You could say this uses
zero space or maybe v space.

547
00:26:52,030 --> 00:26:53,470
One for each vertex.

548
00:26:53,470 --> 00:26:54,139
It depends.

549
00:26:54,139 --> 00:26:56,180
Maybe you don't even need
to explicitly represent

550
00:26:56,180 --> 00:26:58,080
all the vertices.

551
00:26:58,080 --> 00:27:03,500
You start with some vertex,
and given a vertex, somehow

552
00:27:03,500 --> 00:27:06,610
you know how to compute, let's
say in constant time or linear

553
00:27:06,610 --> 00:27:10,270
time or something, the
neighbors of that vertex.

554
00:27:10,270 --> 00:27:11,840
And then from
there, you can keep

555
00:27:11,840 --> 00:27:13,340
searching, keep
computing neighbors,

556
00:27:13,340 --> 00:27:14,590
until you find what you want.

557
00:27:14,590 --> 00:27:16,506
Maybe you don't have to
build the whole graph,

558
00:27:16,506 --> 00:27:19,774
you just need to build enough of
it until you find your answer.

559
00:27:19,774 --> 00:27:21,315
Whatever answer
you're searching for.

560
00:27:21,315 --> 00:27:23,850
Can you think of a situation
where that might be the case?

561
00:27:23,850 --> 00:27:27,205

562
00:27:27,205 --> 00:27:29,330
Where implicit representation
would be a good idea?

563
00:27:29,330 --> 00:27:29,830
Yes.

564
00:27:29,830 --> 00:27:30,710
Rubik's Cubes.

565
00:27:30,710 --> 00:27:31,543
They're really good.

566
00:27:31,543 --> 00:27:33,170
I never want to
build this space.

567
00:27:33,170 --> 00:27:36,060
It has a bajillion states.

568
00:27:36,060 --> 00:27:37,170
A bajillion vertices.

569
00:27:37,170 --> 00:27:38,780
It would take forever.

570
00:27:38,780 --> 00:27:41,580
There's more
configurations of this cube

571
00:27:41,580 --> 00:27:45,590
than there are particles
in the known universe.

572
00:27:45,590 --> 00:27:47,701
I just computed that in my head.

573
00:27:47,701 --> 00:27:50,120
[LAUGHTER]

574
00:27:50,120 --> 00:27:52,130
I have done this
computation recently,

575
00:27:52,130 --> 00:27:55,620
and for five by five by five
it's like 10 to the 40 states.

576
00:27:55,620 --> 00:27:58,359
Or 10 to the 40, 10 to the 60.

577
00:27:58,359 --> 00:28:00,400
There's about 10 to the
80 particles in the known

578
00:28:00,400 --> 00:28:00,940
universe.

579
00:28:00,940 --> 00:28:02,240
10 to the 83 or something.

580
00:28:02,240 --> 00:28:06,750
So this is probably
10 to the 200 or so.

581
00:28:06,750 --> 00:28:07,862
It's a lot.

582
00:28:07,862 --> 00:28:09,070
You never want to build that.

583
00:28:09,070 --> 00:28:11,820
But, it's very easy to
represent this state.

584
00:28:11,820 --> 00:28:13,520
Just store where
all the cubies are.

585
00:28:13,520 --> 00:28:16,410
And it's very easy to see what
are all the configurations you

586
00:28:16,410 --> 00:28:17,640
can reach in one move.

587
00:28:17,640 --> 00:28:20,630
Just try this move, try
this move, try this move.

588
00:28:20,630 --> 00:28:22,371
Put it back and
try the next move.

589
00:28:22,371 --> 00:28:22,870
And so on.

590
00:28:22,870 --> 00:28:25,660

591
00:28:25,660 --> 00:28:27,600
For an m by n by
n cube in order n

592
00:28:27,600 --> 00:28:30,210
time, you can list all
the order n next states.

593
00:28:30,210 --> 00:28:32,050
You can list all the
order n neighbors.

594
00:28:32,050 --> 00:28:35,224
And so you can keep exploring,
searching for your state.

595
00:28:35,224 --> 00:28:37,390
Now you don't want to explore
too far for that cube,

596
00:28:37,390 --> 00:28:41,020
but at least you're
not hosed just

597
00:28:41,020 --> 00:28:44,190
from the problem of
representing the graph.

598
00:28:44,190 --> 00:28:46,030
So even for two by
two by two, it's

599
00:28:46,030 --> 00:28:48,165
useful to do this
mostly to save space.

600
00:28:48,165 --> 00:28:50,310
You're not really saving time.

601
00:28:50,310 --> 00:28:54,960
But you'd like to not have to
store all 264 million states

602
00:28:54,960 --> 00:29:01,850
because it's going to be several
gigabytes and it's annoying.

603
00:29:01,850 --> 00:29:05,650
Speaking of space-- ignoring
the implicit representation--

604
00:29:05,650 --> 00:29:08,755
how much space does this
representation require?

605
00:29:08,755 --> 00:29:19,820

606
00:29:19,820 --> 00:29:22,590
V plus E. This Is
going to be the bread

607
00:29:22,590 --> 00:29:24,609
and butter of our
graph algorithms.

608
00:29:24,609 --> 00:29:27,150
Most of the things we're going
to talk about achieve V plus E

609
00:29:27,150 --> 00:29:27,650
time.

610
00:29:27,650 --> 00:29:29,090
This is essentially optimal.

611
00:29:29,090 --> 00:29:32,162
It's linear in the
size of your graph.

612
00:29:32,162 --> 00:29:34,700
You've got V vertices, E edges.

613
00:29:34,700 --> 00:29:37,160
Technically, in
case you're curious,

614
00:29:37,160 --> 00:29:40,560
this is really the size
of V plus the size of E.

615
00:29:40,560 --> 00:29:44,667
But in the textbook, and
I guess in the world,

616
00:29:44,667 --> 00:29:46,500
we just omit those sizes
of whenever they're

617
00:29:46,500 --> 00:29:49,180
in a theta notation
or Big O notation.

618
00:29:49,180 --> 00:29:50,930
So number vertices
plus number of edges.

619
00:29:50,930 --> 00:29:52,304
that sort of the
bare minimum you

620
00:29:52,304 --> 00:29:55,456
need if you want an explicit
representation of the graph.

621
00:29:55,456 --> 00:29:56,830
And we achieve
that because we've

622
00:29:56,830 --> 00:30:00,880
got we've got v space just to
store the vertices in an array.

623
00:30:00,880 --> 00:30:06,677
And then if you add up--
Each of these is an edge.

624
00:30:06,677 --> 00:30:08,010
You have to be a little careful.

625
00:30:08,010 --> 00:30:11,570
In undirected graphs, each
of these is a half edge.

626
00:30:11,570 --> 00:30:15,340
So there's actually two
times e nodes over here.

627
00:30:15,340 --> 00:30:19,390
But it's theta E.
So theta V plus E

628
00:30:19,390 --> 00:30:22,140
is the amount of space we need.

629
00:30:22,140 --> 00:30:25,090
And ideally, all our algorithms
will run in this much time.

630
00:30:25,090 --> 00:30:28,550
Because that's what you need
just to look at the graph.

631
00:30:28,550 --> 00:31:06,710

632
00:31:06,710 --> 00:31:11,590
So let's do an actual algorithm,
which is breadth-first search.

633
00:31:11,590 --> 00:31:14,920

634
00:31:14,920 --> 00:31:18,420
So to the simplest algorithm
you can think of in graphs.

635
00:31:18,420 --> 00:31:21,090
I've already outlined
it several times.

636
00:31:21,090 --> 00:31:22,640
You start at some node.

637
00:31:22,640 --> 00:31:24,810
You look at all the nodes
you can get to from there.

638
00:31:24,810 --> 00:31:26,976
You look at all the nodes
you can get to from there.

639
00:31:26,976 --> 00:31:29,300
Keep going until you're done.

640
00:31:29,300 --> 00:31:32,110
So this is going to explore
all of the vertices that

641
00:31:32,110 --> 00:31:34,030
are reachable from a node.

642
00:31:34,030 --> 00:31:36,720

643
00:31:36,720 --> 00:31:39,270
The challenge-- The
one annoying thing

644
00:31:39,270 --> 00:31:41,520
about breadth-first search
and why this is not trivial

645
00:31:41,520 --> 00:31:44,280
is that there can
be some edges that

646
00:31:44,280 --> 00:31:52,340
go sort of backwards, like
that, to some previous layer.

647
00:31:52,340 --> 00:31:54,242
Actually, that's
not true, is it?

648
00:31:54,242 --> 00:31:58,090

649
00:31:58,090 --> 00:31:59,275
This can't happen.

650
00:31:59,275 --> 00:32:02,220
You see why?

651
00:32:02,220 --> 00:32:06,280
Because if that edge
existed, then from this node

652
00:32:06,280 --> 00:32:08,205
you'd be able to get here.

653
00:32:08,205 --> 00:32:10,180
So in an undirected
graph, that can't happen.

654
00:32:10,180 --> 00:32:12,520
In a directed graph,
you could conceivably

655
00:32:12,520 --> 00:32:13,660
have a back edge like that.

656
00:32:13,660 --> 00:32:16,270
You'd have to realize, oh,
that's a vertex I've already

657
00:32:16,270 --> 00:32:19,450
seen, I don't want to put
it here, even though it's

658
00:32:19,450 --> 00:32:21,270
something I can
reach from this node,

659
00:32:21,270 --> 00:32:22,961
because I've already been there.

660
00:32:22,961 --> 00:32:24,710
We've got to worry
about things like that.

661
00:32:24,710 --> 00:32:27,260

662
00:32:27,260 --> 00:32:29,970
That's, I guess, the main
thing to worry about.

663
00:32:29,970 --> 00:32:34,620

664
00:32:34,620 --> 00:32:40,950
So our goal is to
visit all the nodes--

665
00:32:40,950 --> 00:32:47,555
the vertices-- reachable
from given node, s.

666
00:32:47,555 --> 00:32:51,470

667
00:32:51,470 --> 00:32:54,720
We want to achieve
V plus E time.

668
00:32:54,720 --> 00:33:00,190

669
00:33:00,190 --> 00:33:10,440
And the idea is to
look at the nodes that

670
00:33:10,440 --> 00:33:15,780
are reachable first
in zero moves.

671
00:33:15,780 --> 00:33:17,040
Zero moves.

672
00:33:17,040 --> 00:33:17,820
That's s.

673
00:33:17,820 --> 00:33:20,390

674
00:33:20,390 --> 00:33:23,480
Then in one move.

675
00:33:23,480 --> 00:33:27,650
Well that's everything you
can reach from s in one step.

676
00:33:27,650 --> 00:33:29,430
That's adjacency of s.

677
00:33:29,430 --> 00:33:32,810
And then two moves,
and three moves, and so

678
00:33:32,810 --> 00:33:36,910
on until we run out of graph.

679
00:33:36,910 --> 00:33:47,800
But we need to be careful
to avoid duplicates.

680
00:33:47,800 --> 00:33:51,090
We want to avoid
revisiting vertices

681
00:33:51,090 --> 00:33:52,090
for a couple of reasons.

682
00:33:52,090 --> 00:33:55,110
One is if we didn't, we
would spend infinite time.

683
00:33:55,110 --> 00:33:56,945
Because we'd just go
there and come back,

684
00:33:56,945 --> 00:33:58,070
and go there and come back.

685
00:33:58,070 --> 00:33:59,740
As long as there's
at least one cycle,

686
00:33:59,740 --> 00:34:00,920
you're going to keep
going around the cycle

687
00:34:00,920 --> 00:34:03,280
forever and ever if you don't
try to avoid duplicates.

688
00:34:03,280 --> 00:34:05,707

689
00:34:05,707 --> 00:34:07,790
So let me write down some
code for this algorithm.

690
00:34:07,790 --> 00:34:09,580
It's pretty straightforward.

691
00:34:09,580 --> 00:34:12,190
So straightforward, we
can be completely explicit

692
00:34:12,190 --> 00:34:14,115
and write [INAUDIBLE] code.

693
00:34:14,115 --> 00:34:18,824

694
00:34:18,824 --> 00:34:21,199
There's a few different ways
to implement this algorithm.

695
00:34:21,199 --> 00:34:23,780
I'll show you my favorite.

696
00:34:23,780 --> 00:34:25,659
The textbook has a
different favorite.

697
00:34:25,659 --> 00:34:42,040

698
00:34:42,040 --> 00:34:44,739
I'm going to write in
pure Python, I believe.

699
00:34:44,739 --> 00:35:57,370

700
00:35:57,370 --> 00:35:58,100
Almost done.

701
00:35:58,100 --> 00:36:30,650

702
00:36:30,650 --> 00:36:33,160
I think I got that right.

703
00:36:33,160 --> 00:36:36,594
So this is at the end
of the while-loop.

704
00:36:36,594 --> 00:36:39,272
And at that point
we should be done.

705
00:36:39,272 --> 00:36:40,730
We can do an actual
example, maybe.

706
00:36:40,730 --> 00:37:16,610

707
00:37:16,610 --> 00:37:19,560
I'm going to do it on
an undirected graph,

708
00:37:19,560 --> 00:37:21,220
but this algorithm
works just as well

709
00:37:21,220 --> 00:37:22,970
on directed and
undirected graphs.

710
00:37:22,970 --> 00:37:28,330

711
00:37:28,330 --> 00:37:30,950
There's an undirected graph.

712
00:37:30,950 --> 00:37:34,890
We're given some
start vertex, s,

713
00:37:34,890 --> 00:37:37,430
and we're given
the graph by being

714
00:37:37,430 --> 00:37:39,850
given the adjacency lists.

715
00:37:39,850 --> 00:37:42,600
So you could iterate over
the vertices of that thing.

716
00:37:42,600 --> 00:37:44,420
Given a vertex, you
can list all the edges

717
00:37:44,420 --> 00:37:47,112
you can reach in one step.

718
00:37:47,112 --> 00:37:48,570
And then the top
of the algorithm's

719
00:37:48,570 --> 00:37:50,400
just some initialization.

720
00:37:50,400 --> 00:37:52,570
The basic structure--
We have this thing

721
00:37:52,570 --> 00:37:55,890
called the frontier,
which is what we just

722
00:37:55,890 --> 00:37:58,920
reached on the previous level.

723
00:37:58,920 --> 00:38:04,480
I think that's going to
be level i minus one.

724
00:38:04,480 --> 00:38:06,225
Just don't want to
make an index error.

725
00:38:06,225 --> 00:38:08,614

726
00:38:08,614 --> 00:38:10,280
These are going to
be all the things you

727
00:38:10,280 --> 00:38:14,970
can reach using exactly
i minus one moves.

728
00:38:14,970 --> 00:38:17,020
And then next is going
to be all the things

729
00:38:17,020 --> 00:38:18,560
you can reach in i moves.

730
00:38:18,560 --> 00:38:21,310

731
00:38:21,310 --> 00:38:24,976
So to get started,
what we know is s.

732
00:38:24,976 --> 00:38:28,580
s is what you can
reach in zero moves.

733
00:38:28,580 --> 00:38:31,540
So we set the level
of s to be zero.

734
00:38:31,540 --> 00:38:33,219
That's the first
line of the code.

735
00:38:33,219 --> 00:38:35,010
There's this other
thing called the parent.

736
00:38:35,010 --> 00:38:36,650
We'll worry about that later.

737
00:38:36,650 --> 00:38:37,720
It's optional.

738
00:38:37,720 --> 00:38:40,700
It gives us some
other fun structure.

739
00:38:40,700 --> 00:38:44,950
We set i to be one because
we just finished level zero.

740
00:38:44,950 --> 00:38:49,600
Frontier of what you can reach
in level zero is just s itself.

741
00:38:49,600 --> 00:38:51,560
So we're going to
put that on the list.

742
00:38:51,560 --> 00:38:54,870
That is level zero. i equals
one So one minus one is zero.

743
00:38:54,870 --> 00:38:56,360
All good.

744
00:38:56,360 --> 00:38:57,810
And then we're going to iterate.

745
00:38:57,810 --> 00:39:00,250
And this is going to
be looking at-- The end

746
00:39:00,250 --> 00:39:02,347
of the iteration
is to increment i.

747
00:39:02,347 --> 00:39:03,930
So you could also
call this a for-loop

748
00:39:03,930 --> 00:39:05,763
except we don't know
when it's going to end.

749
00:39:05,763 --> 00:39:09,609
So it's easier to think of
i incrementing each step

750
00:39:09,609 --> 00:39:11,150
not knowing when
we're going to stop.

751
00:39:11,150 --> 00:39:13,191
We're going to stop whenever
we run out of nodes.

752
00:39:13,191 --> 00:39:16,787
So whenever frontier
is a non-empty list.

753
00:39:16,787 --> 00:39:18,370
the bulk of the work
here is computing

754
00:39:18,370 --> 00:39:19,520
what the next level is.

755
00:39:19,520 --> 00:39:20,860
That's called next.

756
00:39:20,860 --> 00:39:22,330
It's going to be level i.

757
00:39:22,330 --> 00:39:23,310
We do some computation.

758
00:39:23,310 --> 00:39:26,020
Eventually we have
what's on the next level.

759
00:39:26,020 --> 00:39:28,172
Then we set frontier next.

760
00:39:28,172 --> 00:39:29,380
Because that's our new level.

761
00:39:29,380 --> 00:39:31,820
We increment i,
and then invariant

762
00:39:31,820 --> 00:39:35,642
of frontier being level
i minus 1 is preserved.

763
00:39:35,642 --> 00:39:36,350
Right after here.

764
00:39:36,350 --> 00:39:40,100
And then we just keep going
till we run out of nodes.

765
00:39:40,100 --> 00:39:42,230
How do we compute next?

766
00:39:42,230 --> 00:39:44,210
Well, we look at every
node in the frontier,

767
00:39:44,210 --> 00:39:47,660
and we look at all the nodes
you can reach from those nodes.

768
00:39:47,660 --> 00:39:49,120
So every node, u,
in the frontier

769
00:39:49,120 --> 00:39:51,400
and then we look
at-- So this means

770
00:39:51,400 --> 00:39:55,660
there is an edge from u
to v through the picture.

771
00:39:55,660 --> 00:39:58,520
We look at all the edges
from all the frontier nodes

772
00:39:58,520 --> 00:39:59,870
where you can go.

773
00:39:59,870 --> 00:40:02,330
And then the key thing is
we check for duplicates.

774
00:40:02,330 --> 00:40:04,830
We see, have we seen
this node before?

775
00:40:04,830 --> 00:40:08,270
If we have, we would have set
it's level to be something.

776
00:40:08,270 --> 00:40:09,870
If we haven't seen
it, it will not

777
00:40:09,870 --> 00:40:14,160
be in the level hash table
or the level dictionary.

778
00:40:14,160 --> 00:40:18,350
And so if it's not in
there, we'll put it in there

779
00:40:18,350 --> 00:40:20,640
and add it to the next layer.

780
00:40:20,640 --> 00:40:22,860
So that's how you
avoid duplicates.

781
00:40:22,860 --> 00:40:25,890
You set its level to make sure
you will never visit it again,

782
00:40:25,890 --> 00:40:28,870
you add it to the next frontier,
you iterate, you're done.

783
00:40:28,870 --> 00:40:31,359

784
00:40:31,359 --> 00:40:32,900
This is one version
of what you might

785
00:40:32,900 --> 00:40:34,240
call a breadth-first search.

786
00:40:34,240 --> 00:40:36,270
And it achieves
this goal, visiting

787
00:40:36,270 --> 00:40:39,220
all the nodes reachable
from s, in linear time.

788
00:40:39,220 --> 00:40:41,640
Let's see how it works
on a real example.

789
00:40:41,640 --> 00:40:43,740
So first frontier is this thing.

790
00:40:43,740 --> 00:40:46,670

791
00:40:46,670 --> 00:40:49,120
Frontier just has the node
s, so we just look at s,

792
00:40:49,120 --> 00:40:50,930
and we look at all
the edges from s.

793
00:40:50,930 --> 00:40:52,440
We get a and x.

794
00:40:52,440 --> 00:40:56,460
So those get added
to the next frontier.

795
00:40:56,460 --> 00:41:01,040
Maybe before I go too
far, let me switch colors.

796
00:41:01,040 --> 00:41:05,700

797
00:41:05,700 --> 00:41:08,080
Multimedia here.

798
00:41:08,080 --> 00:41:12,576
So here's level one.

799
00:41:12,576 --> 00:41:17,270
All of these guys, we're going
to set their level to one.

800
00:41:17,270 --> 00:41:18,877
They can be reached in one step.

801
00:41:18,877 --> 00:41:19,710
That's pretty clear.

802
00:41:19,710 --> 00:41:22,570
So now frontier is a and x.

803
00:41:22,570 --> 00:41:24,380
That's what next becomes.

804
00:41:24,380 --> 00:41:26,240
Then frontier becomes next.

805
00:41:26,240 --> 00:41:28,510
And so we look at
all the edges from a.

806
00:41:28,510 --> 00:41:31,110
That's going to be s and z.

807
00:41:31,110 --> 00:41:33,730
s, we've already looked at,
it already has a level set,

808
00:41:33,730 --> 00:41:35,200
so we ignore that.

809
00:41:35,200 --> 00:41:35,880
So we look at z.

810
00:41:35,880 --> 00:41:38,200
Z does not have a
level indicated here,

811
00:41:38,200 --> 00:41:39,990
so we're going to
set it to i which

812
00:41:39,990 --> 00:41:42,340
happens to be two at this point.

813
00:41:42,340 --> 00:41:43,200
And we look at x.

814
00:41:43,200 --> 00:41:45,160
It has neighbors s, d, and c.

815
00:41:45,160 --> 00:41:46,330
We look at s again.

816
00:41:46,330 --> 00:41:48,680
We say, oh, we've already
seen that yet again.

817
00:41:48,680 --> 00:41:50,800
So we're worried about
this taking a lot of time

818
00:41:50,800 --> 00:41:54,090
because we look at s
three times in total.

819
00:41:54,090 --> 00:41:56,290
Then we look at d.

820
00:41:56,290 --> 00:41:59,240
d hasn't been set, so we set
it to two. c hasn't been set,

821
00:41:59,240 --> 00:42:00,220
so we set it to two.

822
00:42:00,220 --> 00:42:05,945
So the frontier at
level two is that.

823
00:42:05,945 --> 00:42:07,570
Then we look at all
the neighbors of z.

824
00:42:07,570 --> 00:42:09,489
There's a. a's already been set.

825
00:42:09,489 --> 00:42:10,780
Look at all the neighbors of d.

826
00:42:10,780 --> 00:42:11,370
There's x.

827
00:42:11,370 --> 00:42:11,870
There's c.

828
00:42:11,870 --> 00:42:12,703
Those have been set.

829
00:42:12,703 --> 00:42:13,850
There's f.

830
00:42:13,850 --> 00:42:16,440
This one gets added.

831
00:42:16,440 --> 00:42:17,480
Then we look at c.

832
00:42:17,480 --> 00:42:18,020
There's x.

833
00:42:18,020 --> 00:42:19,770
That's been done. d's been done.

834
00:42:19,770 --> 00:42:20,690
f's been done.

835
00:42:20,690 --> 00:42:23,370
v has not been done.

836
00:42:23,370 --> 00:42:27,300
So this becomes a
frontier at level three.

837
00:42:27,300 --> 00:42:28,930
Then we look at level three.

838
00:42:28,930 --> 00:42:29,577
There's f.

839
00:42:29,577 --> 00:42:31,410
D's been done, c's been
done, b's been done.

840
00:42:31,410 --> 00:42:34,530
We look at v. c's been
done. f's been done.

841
00:42:34,530 --> 00:42:35,710
Nothing to add to next.

842
00:42:35,710 --> 00:42:36,780
Next becomes empty.

843
00:42:36,780 --> 00:42:38,240
Frontier becomes empty.

844
00:42:38,240 --> 00:42:39,530
The while-loop finishes.

845
00:42:39,530 --> 00:42:40,760
TA DA!

846
00:42:40,760 --> 00:42:43,510
We've computed-- we've
visited all the vertices.

847
00:42:43,510 --> 00:42:44,453
Question.

848
00:42:44,453 --> 00:42:45,369
AUDIENCE: [INAUDIBLE].

849
00:42:45,369 --> 00:42:51,325

850
00:42:51,325 --> 00:42:52,910
What notation?

851
00:42:52,910 --> 00:42:54,460
PROFESSOR: This is
Python notation.

852
00:42:54,460 --> 00:42:56,860
You may have heard of Python.

853
00:42:56,860 --> 00:43:01,720
This is a dictionary
which has one key value,

854
00:43:01,720 --> 00:43:03,720
s, and has one value, zero.

855
00:43:03,720 --> 00:43:07,280
So you could-- That's
shorthand in Python

856
00:43:07,280 --> 00:43:10,440
for-- Usually you have
a comma separated list.

857
00:43:10,440 --> 00:43:14,310
The colon is specifying
key value pairs.

858
00:43:14,310 --> 00:43:17,300

859
00:43:17,300 --> 00:43:19,760
I didn't talk about parent.

860
00:43:19,760 --> 00:43:23,310
We can do that for a little bit.

861
00:43:23,310 --> 00:43:28,280
So parent we're initializing to
say, the parent of s is nobody,

862
00:43:28,280 --> 00:43:30,890
and then whenever we
visit a new vertex,

863
00:43:30,890 --> 00:43:34,900
v, we set its parent to be
the vertex that we came from.

864
00:43:34,900 --> 00:43:36,650
So we had this vertex,
v. We had an edge

865
00:43:36,650 --> 00:43:38,560
to v from some vertex, u.

866
00:43:38,560 --> 00:43:40,720
We set the parent of v to be u.

867
00:43:40,720 --> 00:43:44,140
So let me add in
what that becomes.

868
00:43:44,140 --> 00:43:47,300
I'll change colors yet again.

869
00:43:47,300 --> 00:43:51,820
Although it gets hard to
see any color but red.

870
00:43:51,820 --> 00:43:55,340
So we have s.

871
00:43:55,340 --> 00:44:00,810
When we visited a, then the
parent of a would become s.

872
00:44:00,810 --> 00:44:05,150
When we visited z, the
parent of z would be a.

873
00:44:05,150 --> 00:44:07,640
Parent of x is going to be s.

874
00:44:07,640 --> 00:44:09,925
Parent of d is going to be x.

875
00:44:09,925 --> 00:44:12,765
The parent of c
is going to be x.

876
00:44:12,765 --> 00:44:15,620
The parent of f-- it could
have been either way,

877
00:44:15,620 --> 00:44:18,860
but the way I did
it, d went first,

878
00:44:18,860 --> 00:44:21,200
and so that became its parent.

879
00:44:21,200 --> 00:44:25,327
And I think for v,
c was its parent.

880
00:44:25,327 --> 00:44:27,410
So that's what the parent
pointers will look like.

881
00:44:27,410 --> 00:44:28,820
They always follow edges.

882
00:44:28,820 --> 00:44:30,760
They actually follow
edges backwards.

883
00:44:30,760 --> 00:44:32,620
If this was a directed
graph, the graph

884
00:44:32,620 --> 00:44:35,420
might be directed that way
but the parent pointers

885
00:44:35,420 --> 00:44:37,270
go back along the edges.

886
00:44:37,270 --> 00:44:38,390
So it's a way to return.

887
00:44:38,390 --> 00:44:41,710
It's a way to return to s.

888
00:44:41,710 --> 00:44:44,580
If you follow these pointers,
all roads lead to s.

889
00:44:44,580 --> 00:44:48,140

890
00:44:48,140 --> 00:44:50,550
Because we started at s,
that's the property we have.

891
00:44:50,550 --> 00:44:54,180
In fact, these pointers
always form a tree,

892
00:44:54,180 --> 00:44:56,280
and the root of the tree is s.

893
00:44:56,280 --> 00:44:59,860
In fact, these pointers form
what are called shortest paths.

894
00:44:59,860 --> 00:45:05,730
Let me write down a
little bit about this.

895
00:45:05,730 --> 00:45:19,970

896
00:45:19,970 --> 00:45:21,285
Shortest path properties.

897
00:45:21,285 --> 00:45:45,910

898
00:45:45,910 --> 00:45:51,400
If you take a node, and
you take its parent,

899
00:45:51,400 --> 00:45:53,170
and you take the
parent of the parent,

900
00:45:53,170 --> 00:45:56,600
and so on, eventually
you get to s.

901
00:45:56,600 --> 00:45:59,180
And if you read
it backwards, that

902
00:45:59,180 --> 00:46:01,880
will actually be a
path in the graph.

903
00:46:01,880 --> 00:46:10,050
And it will be a shortest
path, in the graph, from s

904
00:46:10,050 --> 00:46:16,100
to v. Meaning, if you look at
all paths in the graph that

905
00:46:16,100 --> 00:46:18,830
go from s to v-- So say
we're going from s to v,

906
00:46:18,830 --> 00:46:23,101
how about that, we compute
this path out of BFS.

907
00:46:23,101 --> 00:46:24,475
Which is, follow
a parent of v is

908
00:46:24,475 --> 00:46:27,670
c, parent of c is
x, parent of x is s.

909
00:46:27,670 --> 00:46:28,600
Read it backwards.

910
00:46:28,600 --> 00:46:30,590
That gives us a
path from s to v.

911
00:46:30,590 --> 00:46:32,140
The claim is, that
is the shortest

912
00:46:32,140 --> 00:46:35,420
way to get from s to v. It
might not be the only one.

913
00:46:35,420 --> 00:46:38,330
Like if you're going from s
to f, there's two short paths.

914
00:46:38,330 --> 00:46:40,330
There's this one
of length three.

915
00:46:40,330 --> 00:46:42,160
There's this one
of length three..

916
00:46:42,160 --> 00:46:43,390
Uses three edges.

917
00:46:43,390 --> 00:46:45,300
Same length.

918
00:46:45,300 --> 00:46:47,110
And in the parent
pointers, we can only

919
00:46:47,110 --> 00:46:48,640
afford to encode
one of those paths

920
00:46:48,640 --> 00:46:51,015
because in general there might
be exponentially many ways

921
00:46:51,015 --> 00:46:52,690
to get from one node to another.

922
00:46:52,690 --> 00:46:56,940
We find a shortest path, not
necessarily the only one.

923
00:46:56,940 --> 00:47:01,075
And the length of that
path-- So shortest

924
00:47:01,075 --> 00:47:03,750
here means that you
use the fewest edges.

925
00:47:03,750 --> 00:47:07,690
And the length
will be level of v.

926
00:47:07,690 --> 00:47:10,729
That's what we're
keeping track of.

927
00:47:10,729 --> 00:47:13,020
If the level's zero, you can
get there with zero steps.

928
00:47:13,020 --> 00:47:15,060
If the level's one, you
get there with one steps.

929
00:47:15,060 --> 00:47:17,143
Because we're visiting
everything you can possibly

930
00:47:17,143 --> 00:47:19,500
get in k steps, the
level is telling you

931
00:47:19,500 --> 00:47:21,411
what that shortest
path distance is.

932
00:47:21,411 --> 00:47:22,910
And the parent
pointers are actually

933
00:47:22,910 --> 00:47:25,030
giving you the shortest path.

934
00:47:25,030 --> 00:47:27,090
That's the cool thing about BFS.

935
00:47:27,090 --> 00:47:28,620
Yeah, BFS explores the vertices.

936
00:47:28,620 --> 00:47:30,416
Sometimes, that's
all you care about.

937
00:47:30,416 --> 00:47:32,040
But in some sense,
what really matters,

938
00:47:32,040 --> 00:47:36,200
is it finds the shortest way to
get from anywhere to anywhere.

939
00:47:36,200 --> 00:47:40,200
For a Rubik's Cube,
that's nice because you

940
00:47:40,200 --> 00:47:43,260
run BFS from the start
state of the Rubik's Cube.

941
00:47:43,260 --> 00:47:45,190
Then you say, oh,
I'm in this state.

942
00:47:45,190 --> 00:47:46,724
You look up this state.

943
00:47:46,724 --> 00:47:47,640
You look at its level.

944
00:47:47,640 --> 00:47:50,590
It says, oh, you can
get there in nine steps.

945
00:47:50,590 --> 00:47:52,260
That's, I think, the average.

946
00:47:52,260 --> 00:47:53,501
So I'm guessing.

947
00:47:53,501 --> 00:47:55,250
I don't know how to
do this in nine steps.

948
00:47:55,250 --> 00:47:58,470

949
00:47:58,470 --> 00:48:00,220
Great, so now you
know how to solve it.

950
00:48:00,220 --> 00:48:01,720
You just look at
the parent pointer.

951
00:48:01,720 --> 00:48:03,095
The parent pointer gives
you another configuration.

952
00:48:03,095 --> 00:48:05,030
You say, oh, what move was that?

953
00:48:05,030 --> 00:48:06,480
And then you do that move.

954
00:48:06,480 --> 00:48:07,940
I'm not going to solve it.

955
00:48:07,940 --> 00:48:09,360
Then you look at the
parent pointer of that.

956
00:48:09,360 --> 00:48:10,045
You do that move.

957
00:48:10,045 --> 00:48:11,510
You look at the parent
pointer of that.

958
00:48:11,510 --> 00:48:12,080
You do that move.

959
00:48:12,080 --> 00:48:13,871
Eventually, you'll get
to the solved state,

960
00:48:13,871 --> 00:48:16,430
and you will do it using
the fewest possible moves.

961
00:48:16,430 --> 00:48:20,590
So if you can afford to put the
whole graph in memory, which

962
00:48:20,590 --> 00:48:23,450
you can't for a big Rubik's Cube
but you can for a small one,

963
00:48:23,450 --> 00:48:27,560
then this will give you a
strategy, the optimal strategy,

964
00:48:27,560 --> 00:48:32,400
God's algorithm if you will,
for every configuration.

965
00:48:32,400 --> 00:48:34,200
It solves all of them.

966
00:48:34,200 --> 00:48:36,199
Which is great.

967
00:48:36,199 --> 00:48:37,990
What is the running
time of this algorithm?

968
00:48:37,990 --> 00:48:41,870
I claim it's order V plus E.
But it looked a little wasteful

969
00:48:41,870 --> 00:48:45,300
because it was checking
vertices over and over and over.

970
00:48:45,300 --> 00:48:47,260
But if you think
about it carefully,

971
00:48:47,260 --> 00:48:50,110
you're only looking--
what's the right way

972
00:48:50,110 --> 00:48:55,584
to say this-- you only
check every edge once.

973
00:48:55,584 --> 00:48:57,500
Or in undirected graphs,
you check them twice,

974
00:48:57,500 --> 00:49:00,820
once from each side.

975
00:49:00,820 --> 00:49:04,290
A vertex enters the
frontier only once.

976
00:49:04,290 --> 00:49:07,610
Because once it's in the
frontier, it gets a level set.

977
00:49:07,610 --> 00:49:11,450
And once it has a level set,
it'll never go in again.

978
00:49:11,450 --> 00:49:14,450
It'll never get added to next.

979
00:49:14,450 --> 00:49:17,440
So s gets added once then we
check all the neighbors of s.

980
00:49:17,440 --> 00:49:19,910
a gets added once, then we
check all the neighbors of a.

981
00:49:19,910 --> 00:49:21,520
Each of these guys
gets added once.

982
00:49:21,520 --> 00:49:22,950
We check all the neighbors.

983
00:49:22,950 --> 00:49:24,410
So the total running
time is going

984
00:49:24,410 --> 00:49:27,490
to be the sum over all
vertices of the size

985
00:49:27,490 --> 00:49:33,530
of the adjacency list of v. So
this is the number of neighbors

986
00:49:33,530 --> 00:49:35,220
that v has.

987
00:49:35,220 --> 00:49:37,579
And this is going to be?

988
00:49:37,579 --> 00:49:38,079
Answer?

989
00:49:38,079 --> 00:49:42,336

990
00:49:42,336 --> 00:49:44,004
AUDIENCE: Two times
the number of edges.

991
00:49:44,004 --> 00:49:44,670
PROFESSOR: Sorry

992
00:49:44,670 --> 00:49:46,211
AUDIENCE: Double
the number of edges.

993
00:49:46,211 --> 00:49:48,930
PROFESSOR: Twice the number of
edges for undirected graphs.

994
00:49:48,930 --> 00:49:51,330
It's going to be the number
of edges for directed graphs.

995
00:49:51,330 --> 00:49:52,770
This is the Handshaking Lemma.

996
00:49:52,770 --> 00:49:54,670
If you don't remember
the Handshaking Lemma,

997
00:49:54,670 --> 00:49:57,330
you should read the textbook.

998
00:49:57,330 --> 00:49:59,116
Six o four two stuff.

999
00:49:59,116 --> 00:50:03,300

1000
00:50:03,300 --> 00:50:06,780
Basically you visit
every edge twice.

1001
00:50:06,780 --> 00:50:10,870
For directed graphs, you
visit every edge once.

1002
00:50:10,870 --> 00:50:13,590
But it's order E. We
also spend order V

1003
00:50:13,590 --> 00:50:15,790
because we touch every vertex.

1004
00:50:15,790 --> 00:50:18,770
So the total running
time is order V plus E.

1005
00:50:18,770 --> 00:50:23,240
In fact, the way this is going,
you can be a little tighter

1006
00:50:23,240 --> 00:50:25,330
and say it's order
E. I just want

1007
00:50:25,330 --> 00:50:27,244
to mention in
reality-- Sometimes

1008
00:50:27,244 --> 00:50:29,410
you don't care about just
what you can reach from s,

1009
00:50:29,410 --> 00:50:31,410
you really want to
visit every vertex.

1010
00:50:31,410 --> 00:50:33,710
Then you need another
outer loop that's

1011
00:50:33,710 --> 00:50:38,170
iterating over all the vertices
as potential choices for s.

1012
00:50:38,170 --> 00:50:41,160
And you then can visit all the
vertices in the entire graph

1013
00:50:41,160 --> 00:50:42,930
even if it's disconnected.

1014
00:50:42,930 --> 00:50:45,040
We'll talk more about
that next class.

1015
00:50:45,040 --> 00:50:46,607
That's it for BFS.

1016
00:50:46,607 --> 00:50:47,107