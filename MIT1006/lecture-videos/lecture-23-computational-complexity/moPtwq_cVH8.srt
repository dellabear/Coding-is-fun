1
00:00:00,000 --> 00:00:00,080

2
00:00:00,080 --> 00:00:01,770
The following
content is provided

3
00:00:01,770 --> 00:00:04,010
under a Creative
Commons license.

4
00:00:04,010 --> 00:00:06,860
Your support will help MIT
OpenCourseWare continue

5
00:00:06,860 --> 00:00:10,720
to offer high quality
educational resources for free.

6
00:00:10,720 --> 00:00:13,330
To make a donation or
view additional materials

7
00:00:13,330 --> 00:00:17,226
from hundreds of MIT courses,
visit MIT OpenCourseWare

8
00:00:17,226 --> 00:00:17,851
at ocw.mit.edu.

9
00:00:17,851 --> 00:00:22,720

10
00:00:22,720 --> 00:00:26,270
PROFESSOR: Today, we are going
to do computational complexity.

11
00:00:26,270 --> 00:00:28,989
This is rather different
from every other thing

12
00:00:28,989 --> 00:00:30,030
we've seen in this class.

13
00:00:30,030 --> 00:00:32,729

14
00:00:32,729 --> 00:00:36,120
This class is basically about
polynomial time algorithms

15
00:00:36,120 --> 00:00:38,580
and problems where we
can solve your problem

16
00:00:38,580 --> 00:00:40,290
in polynomial time.

17
00:00:40,290 --> 00:00:43,130
And today, it's about
when you can't do that.

18
00:00:43,130 --> 00:00:44,880
Sometimes, we can prove
you can't do that.

19
00:00:44,880 --> 00:00:47,020
Sometimes, we're pretty
sure you can't do that.

20
00:00:47,020 --> 00:00:49,140
But it's all about
negative results

21
00:00:49,140 --> 00:00:52,850
when your problems
are really complex.

22
00:00:52,850 --> 00:00:55,040
And there's a lot
of fun topics, here.

23
00:00:55,040 --> 00:00:59,280
This is the topic of
entire classes, like 6045.

24
00:00:59,280 --> 00:01:02,950
We're just going to get
a 1 hour flavor of it.

25
00:01:02,950 --> 00:01:04,519
So think of it as
a high level intro.

26
00:01:04,519 --> 00:01:06,893
But we're going to prove real
theorems and do real things

27
00:01:06,893 --> 00:01:09,580
and you'll get a sense
of how all this works.

28
00:01:09,580 --> 00:01:13,680
So I'm going to start out with
three complexity classes--

29
00:01:13,680 --> 00:01:21,390
P, EXP, and R. How many
people know what P is?

30
00:01:21,390 --> 00:01:23,760
And it is?

31
00:01:23,760 --> 00:01:25,990
Polynomial time.

32
00:01:25,990 --> 00:01:28,510
More precisely, it's
the set of all problems

33
00:01:28,510 --> 00:01:30,060
you can solve in
polynomial time.

34
00:01:30,060 --> 00:01:35,590

35
00:01:35,590 --> 00:01:37,090
This is what the
class is all about.

36
00:01:37,090 --> 00:01:39,736

37
00:01:39,736 --> 00:01:41,110
Almost every
problem we have seen

38
00:01:41,110 --> 00:01:44,410
in this class-- there's
one exception-- is

39
00:01:44,410 --> 00:01:48,960
in P. Does anyone
know the exception?

40
00:01:48,960 --> 00:01:51,150
It's a good puzzle for you.

41
00:01:51,150 --> 00:01:51,940
Not NP.

42
00:01:51,940 --> 00:01:52,440
What's next?

43
00:01:52,440 --> 00:01:55,120
EXP.

44
00:01:55,120 --> 00:01:56,660
How many people
know what EXP is?

45
00:01:56,660 --> 00:01:58,810
Or you can guess.

46
00:01:58,810 --> 00:02:00,400
Any guesses?

47
00:02:00,400 --> 00:02:01,569
Exponential.

48
00:02:01,569 --> 00:02:04,110
These are all the problems you
can solve in exponential time.

49
00:02:04,110 --> 00:02:21,190

50
00:02:21,190 --> 00:02:23,210
If you want to be formal
about it, in this case,

51
00:02:23,210 --> 00:02:29,200
exponential means 2 to
the n to some constant.

52
00:02:29,200 --> 00:02:31,700
So not just 2 the n, but also
2 to the n squared, 2 to the n

53
00:02:31,700 --> 00:02:32,199
cubed.

54
00:02:32,199 --> 00:02:34,350
Those are all
considered-- exponential

55
00:02:34,350 --> 00:02:38,050
and a polynomial is
considered in the class EXP.

56
00:02:38,050 --> 00:02:42,010
Now, basically, almost every
problem you can dream of you

57
00:02:42,010 --> 00:02:43,170
can solve in EXP.

58
00:02:43,170 --> 00:02:45,370
Exponential time
is so much time.

59
00:02:45,370 --> 00:02:47,705
And this class has always
been about taking things that

60
00:02:47,705 --> 00:02:51,460
are obviously in EXP and showing
that they're actually in P.

61
00:02:51,460 --> 00:02:53,120
So if you want to
draw a picture,

62
00:02:53,120 --> 00:02:54,870
you could say, OK,
here's all the problems

63
00:02:54,870 --> 00:02:57,070
we can solve in polynomial time.

64
00:02:57,070 --> 00:03:00,287
Here's all the problems we
can solve in exponential time.

65
00:03:00,287 --> 00:03:01,620
And there are problems out here.

66
00:03:01,620 --> 00:03:03,390
These are different classes.

67
00:03:03,390 --> 00:03:06,070
And we want to sort
of bring things

68
00:03:06,070 --> 00:03:09,620
into here as much as possible.

69
00:03:09,620 --> 00:03:11,940
I actually want to
draw this picture

70
00:03:11,940 --> 00:03:16,050
in a different way, which
is as a horizontal line.

71
00:03:16,050 --> 00:03:20,760

72
00:03:20,760 --> 00:03:21,715
So an axis.

73
00:03:21,715 --> 00:03:24,860

74
00:03:24,860 --> 00:03:27,949
I'm going to call this
computational difficulty.

75
00:03:27,949 --> 00:03:29,740
You could call it
computational complexity,

76
00:03:29,740 --> 00:03:30,930
but that's a bit of
a loaded term that

77
00:03:30,930 --> 00:03:32,470
actually has formal meaning.

78
00:03:32,470 --> 00:03:34,000
Difficulty is nice and vague.

79
00:03:34,000 --> 00:03:36,040
So I can draw an
abstract picture.

80
00:03:36,040 --> 00:03:38,460
This is not a true
diagram, but it's

81
00:03:38,460 --> 00:03:40,770
a very good guideline
of what's going on.

82
00:03:40,770 --> 00:03:46,905
So we have-- I'm going to draw--
I believe-- three notches.

83
00:03:46,905 --> 00:03:50,200

84
00:03:50,200 --> 00:03:52,770
No, eventually four, so let
me give myself some room.

85
00:03:52,770 --> 00:03:56,480

86
00:03:56,480 --> 00:04:01,920
We have over here, the
easy problems are P. Then,

87
00:04:01,920 --> 00:04:05,180
we have these problems,
which are EXP.

88
00:04:05,180 --> 00:04:08,930
We're going to fill in
something in the middle.

89
00:04:08,930 --> 00:04:11,910
And then this is
something called R.

90
00:04:11,910 --> 00:04:13,410
So you've got P is
everything, here.

91
00:04:13,410 --> 00:04:19,140
EXP is all the way out to
here, in some abstract view.

92
00:04:19,140 --> 00:04:23,290
The next thing is R. How
many people know what R is?

93
00:04:23,290 --> 00:04:26,250
This one, I had to look up.

94
00:04:26,250 --> 00:04:29,780
It's not usually given a name.

95
00:04:29,780 --> 00:04:30,805
No one.

96
00:04:30,805 --> 00:04:31,430
Teaching staff?

97
00:04:31,430 --> 00:04:32,445
You guys know it?

98
00:04:32,445 --> 00:04:36,500

99
00:04:36,500 --> 00:04:39,900
These are all problems
solvable in finite time.

100
00:04:39,900 --> 00:04:40,910
R stands for finite.

101
00:04:40,910 --> 00:04:49,980

102
00:04:49,980 --> 00:04:52,280
R stands for recursive.

103
00:04:52,280 --> 00:04:54,530
Recursive used to mean
something completely different,

104
00:04:54,530 --> 00:04:56,863
back in the '30s, when people
were thinking about what's

105
00:04:56,863 --> 00:04:58,470
computable, what's
not computable.

106
00:04:58,470 --> 00:05:02,390
These are, basically, solvable
problems, computable problems.

107
00:05:02,390 --> 00:05:04,890
Finite time is a reasonable
requirement, I think,

108
00:05:04,890 --> 00:05:06,105
for all algorithms.

109
00:05:06,105 --> 00:05:09,690
And that's R. Now,
I've drawn this arrow

110
00:05:09,690 --> 00:05:13,106
to keep going because there
are problems out here.

111
00:05:13,106 --> 00:05:14,605
It's kind of
discouraging, but there

112
00:05:14,605 --> 00:05:17,080
are problems that
are unsolvable.

113
00:05:17,080 --> 00:05:19,977
In fact, most problems
are unsolvable.

114
00:05:19,977 --> 00:05:21,060
We're going to prove that.

115
00:05:21,060 --> 00:05:23,340
It's actually really
easy to prove.

116
00:05:23,340 --> 00:05:28,360
Kind of depressing, but true.

117
00:05:28,360 --> 00:05:31,820
Let me start with some examples
before we get to that proof.

118
00:05:31,820 --> 00:05:36,200

119
00:05:36,200 --> 00:05:40,730
So I'm writing examples
of some things we've seen.

120
00:05:40,730 --> 00:05:44,170
So here's an example of
a problem we've seen.

121
00:05:44,170 --> 00:05:47,740

122
00:05:47,740 --> 00:05:49,095
Negative-weight cycle detection.

123
00:05:49,095 --> 00:05:52,314

124
00:05:52,314 --> 00:05:54,440
I give you a graph--
a weighted graph.

125
00:05:54,440 --> 00:05:58,090
I want to know does it have
any negative-weight cycles?

126
00:05:58,090 --> 00:06:00,560
What classes is this problem in?

127
00:06:00,560 --> 00:06:03,050
P. We know how to solve
this in polynomial time--

128
00:06:03,050 --> 00:06:06,260
in VE time-- using Bellman-Ford.

129
00:06:06,260 --> 00:06:08,650
VE time-- well, that finds
negative-weight cycles

130
00:06:08,650 --> 00:06:09,540
reachable from s.

131
00:06:09,540 --> 00:06:11,370
But, I guess, if you
add a source that

132
00:06:11,370 --> 00:06:14,390
can reach anywhere--
zero weight-- then

133
00:06:14,390 --> 00:06:18,390
that'll tell you
overall that it's in P.

134
00:06:18,390 --> 00:06:19,640
It's also in EXP, of course.

135
00:06:19,640 --> 00:06:21,322
Everything in P is also in EXP.

136
00:06:21,322 --> 00:06:23,280
Because if you can solve
it in polynomial time,

137
00:06:23,280 --> 00:06:25,290
you can solve it in
exponential time.

138
00:06:25,290 --> 00:06:29,230
This is at most
exponential time.

139
00:06:29,230 --> 00:06:30,048
At most polynomial.

140
00:06:30,048 --> 00:06:33,440

141
00:06:33,440 --> 00:06:35,680
Here's a problem
we haven't seen.

142
00:06:35,680 --> 00:06:37,160
But it's pretty cool.

143
00:06:37,160 --> 00:06:39,190
N by n Chess.

144
00:06:39,190 --> 00:06:41,320
So this is the
problem I give you.

145
00:06:41,320 --> 00:06:43,440
So we're in an by n
board, and I give you

146
00:06:43,440 --> 00:06:45,690
a whole bunch of
pieces on the board,

147
00:06:45,690 --> 00:06:48,890
and I want to know does
White win from here?

148
00:06:48,890 --> 00:06:51,660
I say it's White to
move or Black to move,

149
00:06:51,660 --> 00:06:55,250
and who's going to win
form this position?

150
00:06:55,250 --> 00:06:59,085
This problem, can be
solved in exponential time.

151
00:06:59,085 --> 00:07:02,080
You can sort of play out
all possible strategies

152
00:07:02,080 --> 00:07:05,210
and see who wins.

153
00:07:05,210 --> 00:07:10,060
And it's not in P. There's
no polynomial time algorithm

154
00:07:10,060 --> 00:07:12,150
to play generalized Chess.

155
00:07:12,150 --> 00:07:15,250
This sort of captures why
Chess-- even at eight by eight

156
00:07:15,250 --> 00:07:17,510
Chess-- is hard-- because
there's no general way

157
00:07:17,510 --> 00:07:19,220
to do it.

158
00:07:19,220 --> 00:07:23,210
So there's no special
way to do it, probably.

159
00:07:23,210 --> 00:07:25,780
Computational complexity is
all about order of growth.

160
00:07:25,780 --> 00:07:27,770
So we can't analyze
eight by eight Chess,

161
00:07:27,770 --> 00:07:29,290
but we can analyze n by n Chess.

162
00:07:29,290 --> 00:07:32,290
And that gives us a flavor of
why 8 by 8 is so difficult.

163
00:07:32,290 --> 00:07:37,000
Go is also in EXP, but
not in P-- lots of games

164
00:07:37,000 --> 00:07:41,430
are in this category, lot's of
complicated games, let's say.

165
00:07:41,430 --> 00:07:45,130
And so this is a first example
of a problem that we know we

166
00:07:45,130 --> 00:07:48,930
cannot solve in polynomial time.

167
00:07:48,930 --> 00:07:50,880
Bad news.

168
00:07:50,880 --> 00:07:53,070
I also talked about
Tetris a little bit.

169
00:07:53,070 --> 00:07:56,940

170
00:07:56,940 --> 00:07:58,920
Unlike the Tetris
training, which we saw,

171
00:07:58,920 --> 00:08:00,630
this is sort of
realistic Tetris--

172
00:08:00,630 --> 00:08:02,340
all the rules of Tetris.

173
00:08:02,340 --> 00:08:04,990
The only catch is that I
tell you all the pieces that

174
00:08:04,990 --> 00:08:06,470
are going to come in advance.

175
00:08:06,470 --> 00:08:08,442
Because, otherwise,
it's some random process

176
00:08:08,442 --> 00:08:11,025
and it's kind of hard to think
about what's the best strategy.

177
00:08:11,025 --> 00:08:13,524
But if I tell you
what's going to come--

178
00:08:13,524 --> 00:08:14,940
say it's a
pseudo-random generator

179
00:08:14,940 --> 00:08:16,365
and you know how it works.

180
00:08:16,365 --> 00:08:17,990
You know all the
pieces that will come.

181
00:08:17,990 --> 00:08:22,830
I want to know can I survive
from a given initial board mess

182
00:08:22,830 --> 00:08:24,980
and for a given
sequence of pieces.

183
00:08:24,980 --> 00:08:27,740
This can also be solved
in exponential time.

184
00:08:27,740 --> 00:08:29,575
Just try all the possibilities.

185
00:08:29,575 --> 00:08:34,780

186
00:08:34,780 --> 00:08:45,760
We don't know whether it's
in P. We're pretty sure

187
00:08:45,760 --> 00:08:47,920
it's not in P. And by the
end of today's lecture,

188
00:08:47,920 --> 00:08:51,500
you'll understand why
we think it's not in P.

189
00:08:51,500 --> 00:08:54,930
But it's going to be
somewhere in between here.

190
00:08:54,930 --> 00:08:57,110
Tetris is actually right here.

191
00:08:57,110 --> 00:08:59,410
But I haven't defined
what right here is yet.

192
00:08:59,410 --> 00:09:06,040

193
00:09:06,040 --> 00:09:10,460
And then the next one
is halting problem.

194
00:09:10,460 --> 00:09:24,720

195
00:09:24,720 --> 00:09:27,140
So halting problem
is particularly cool,

196
00:09:27,140 --> 00:09:29,320
as we'll see-- or interesting.

197
00:09:29,320 --> 00:09:34,710
It's the problem of given a
computer program-- Python,

198
00:09:34,710 --> 00:09:37,540
whatever, it doesn't really
matter what language.

199
00:09:37,540 --> 00:09:42,150
They're all the same in
a theoretical sense--

200
00:09:42,150 --> 00:09:43,005
does it ever halt?

201
00:09:43,005 --> 00:09:46,680

202
00:09:46,680 --> 00:09:50,335
Does it ever stop running,
return a result, whatever?

203
00:09:50,335 --> 00:09:53,070

204
00:09:53,070 --> 00:09:55,600
This would be really handy--
you're writing some code,

205
00:09:55,600 --> 00:09:58,360
and you've run it
for 5 hours, and you

206
00:09:58,360 --> 00:10:00,120
don't know is that
because there's a bug

207
00:10:00,120 --> 00:10:01,453
and you've got an infinite loop?

208
00:10:01,453 --> 00:10:04,000
Or is it just because
it's really slow?

209
00:10:04,000 --> 00:10:08,137
So you'd like to give it
to some program-- checking

210
00:10:08,137 --> 00:10:09,845
program-- that says
will this run forever

211
00:10:09,845 --> 00:10:11,532
or will it terminate.

212
00:10:11,532 --> 00:10:13,160
That's the halting problem.

213
00:10:13,160 --> 00:10:17,080
And this problem
is not in R. There

214
00:10:17,080 --> 00:10:20,260
is no correct algorithm
for solving this problem.

215
00:10:20,260 --> 00:10:24,270
There's no way to tell,
given an arbitrary program,

216
00:10:24,270 --> 00:10:25,840
whether it will halt.

217
00:10:25,840 --> 00:10:28,130
Now, in some situations--
take the empty program--

218
00:10:28,130 --> 00:10:29,630
I can tell that it halts.

219
00:10:29,630 --> 00:10:33,580
Or I take some special
simple class of programs,

220
00:10:33,580 --> 00:10:36,890
I can tell whether they halt or
determine that they don't halt.

221
00:10:36,890 --> 00:10:40,890
But there's no algorithm that
solves it for all programs,

222
00:10:40,890 --> 00:10:42,380
in finite time.

223
00:10:42,380 --> 00:10:44,330
In infinite time,
I can solve it.

224
00:10:44,330 --> 00:10:46,540
Just run it.

225
00:10:46,540 --> 00:10:48,340
Run the program.

226
00:10:48,340 --> 00:10:50,340
Given finite time, there's
no way to solve this.

227
00:10:50,340 --> 00:10:53,370
And so this is a little bit
beyond what we can prove today.

228
00:10:53,370 --> 00:10:54,930
It's not that hard
to prove, but it

229
00:10:54,930 --> 00:10:56,440
takes half an hour or something.

230
00:10:56,440 --> 00:10:57,690
I want to get to other things.

231
00:10:57,690 --> 00:11:02,020
But if you take 6045,
they'll prove this.

232
00:11:02,020 --> 00:11:03,990
What I want to show you
instead is an easier

233
00:11:03,990 --> 00:11:29,800
result-- that almost
every problem is not in R.

234
00:11:29,800 --> 00:11:32,680
I need one term, though,
which is decision problems.

235
00:11:32,680 --> 00:11:35,050
All of these problems,
I set it up in a way

236
00:11:35,050 --> 00:11:37,556
that the answer is
binary-- yes or no.

237
00:11:37,556 --> 00:11:38,930
Is there a
negative-weight cycle?

238
00:11:38,930 --> 00:11:41,090
Yes or no?

239
00:11:41,090 --> 00:11:43,950
Does White win from
this position in Chess?

240
00:11:43,950 --> 00:11:46,000
Can you survive in Tetris?

241
00:11:46,000 --> 00:11:48,240
And does this program halt?

242
00:11:48,240 --> 00:11:51,430
For various reasons--
basically convenience--

243
00:11:51,430 --> 00:11:53,320
the whole field of
computational complexity

244
00:11:53,320 --> 00:11:56,550
focuses on decision problems.

245
00:11:56,550 --> 00:11:59,370
And, in fact-- so
decision problems

246
00:11:59,370 --> 00:12:01,080
are ones where the
answer is yes or no.

247
00:12:01,080 --> 00:12:02,920
That's all.

248
00:12:02,920 --> 00:12:03,880
Why?

249
00:12:03,880 --> 00:12:05,520
Essentially because
it doesn't matter.

250
00:12:05,520 --> 00:12:07,920
If you take a problem
you care about,

251
00:12:07,920 --> 00:12:10,200
you can convert it into
a decision problem.

252
00:12:10,200 --> 00:12:12,760
We can see examples
of that later.

253
00:12:12,760 --> 00:12:14,290
Decision problems
are basically as

254
00:12:14,290 --> 00:12:17,989
hard as optimization
problems or whatever.

255
00:12:17,989 --> 00:12:19,530
But let's focus on
decision problems.

256
00:12:19,530 --> 00:12:20,920
The answer is yes or no.

257
00:12:20,920 --> 00:12:23,590
Claim that most of
them are uncomputable.

258
00:12:23,590 --> 00:12:26,100
And we can prove
this pretty easily

259
00:12:26,100 --> 00:12:30,390
if you know a bit of
set theory, I guess.

260
00:12:30,390 --> 00:12:35,309

261
00:12:35,309 --> 00:12:37,350
On the one hand, I have
problems I want to solve.

262
00:12:37,350 --> 00:12:38,520
These are decision problems.

263
00:12:38,520 --> 00:12:41,220
And on the other hand,
I have algorithms,

264
00:12:41,220 --> 00:12:42,820
or computer programs
to solve them.

265
00:12:42,820 --> 00:12:44,445
I'm going to think
of computer programs

266
00:12:44,445 --> 00:12:46,640
because more precise
algorithms can

267
00:12:46,640 --> 00:12:50,230
be a little bit nebulous for
thinking about pseudocode--

268
00:12:50,230 --> 00:12:51,460
what's valid, what's invalid.

269
00:12:51,460 --> 00:12:53,610
But computer programs
are very clear.

270
00:12:53,610 --> 00:12:55,049
I give you some code.

271
00:12:55,049 --> 00:12:56,090
You throw it into Python.

272
00:12:56,090 --> 00:12:57,500
Either it works or it doesn't.

273
00:12:57,500 --> 00:12:59,552
And it does something.

274
00:12:59,552 --> 00:13:00,260
Runs for a while.

275
00:13:00,260 --> 00:13:04,080

276
00:13:04,080 --> 00:13:08,750
How can I think about the
space of all possible programs?

277
00:13:08,750 --> 00:13:12,020
Well, programs are things
you type into a computer

278
00:13:12,020 --> 00:13:13,400
in ASCII, whatever.

279
00:13:13,400 --> 00:13:16,380
In the end, you can think of
it as just as a binary string.

280
00:13:16,380 --> 00:13:18,060
Somehow it gets
encoded in binary.

281
00:13:18,060 --> 00:13:21,870
Everything is reduced to binary
in the end, on a computer.

282
00:13:21,870 --> 00:13:27,340
So this is a binary string.

283
00:13:27,340 --> 00:13:29,430
Now, you can also think
of a binary string

284
00:13:29,430 --> 00:13:33,280
as representing a
number, in binary.

285
00:13:33,280 --> 00:13:34,870
So you can also
think of a program,

286
00:13:34,870 --> 00:13:38,960
then, as a natural number-- some
number between 0 and infinity.

287
00:13:38,960 --> 00:13:41,870
And an integer.

288
00:13:41,870 --> 00:13:45,850
So usually we represent
this as math bold N.

289
00:13:45,850 --> 00:13:48,470
That's just 0, 1, 2, 3.

290
00:13:48,470 --> 00:13:50,670
You can think of every
program is ultimately

291
00:13:50,670 --> 00:13:51,960
reducing to an integer.

292
00:13:51,960 --> 00:13:53,615
It's a big integer, but, hey.

293
00:13:53,615 --> 00:13:55,770
It's an integer.

294
00:13:55,770 --> 00:13:57,647
So that's the space
of all programs.

295
00:13:57,647 --> 00:14:00,230
Now, I want to think about the
space of all decision problems.

296
00:14:00,230 --> 00:14:02,900

297
00:14:02,900 --> 00:14:06,474
So how can I define
a decision problem?

298
00:14:06,474 --> 00:14:08,640
Well, the natural way to
think of a decision problem

299
00:14:08,640 --> 00:14:12,650
is as a function that
maps inputs to yes or no.

300
00:14:12,650 --> 00:14:19,350

301
00:14:19,350 --> 00:14:28,430
Function from
inputs to yes or no.

302
00:14:28,430 --> 00:14:32,310
Or you can think
of that as 1 and 0.

303
00:14:32,310 --> 00:14:34,310
So what's an input?

304
00:14:34,310 --> 00:14:36,220
Well, an input is
a binary string.

305
00:14:36,220 --> 00:14:39,000
So an input is a number--
a natural number.

306
00:14:39,000 --> 00:14:41,790

307
00:14:41,790 --> 00:14:51,580
Input is a binary string, which
we can think of as being in N.

308
00:14:51,580 --> 00:14:58,570
So we've got a
function from N to 0,1.

309
00:14:58,570 --> 00:15:03,000
So another way to represent
one of these functions

310
00:15:03,000 --> 00:15:04,220
is as a table.

311
00:15:04,220 --> 00:15:06,070
I could just write
down all the answers.

312
00:15:06,070 --> 00:15:10,110
So I've got, well, the input
could be 0-- the number 0.

313
00:15:10,110 --> 00:15:11,969
And then, maybe it's a 0.

314
00:15:11,969 --> 00:15:14,260
Input could be could be 1
and then, maybe, output is 0.

315
00:15:14,260 --> 00:15:21,750
Then, the input could be 2,
3, 4, 5, 1, 0, 1, 1, whatever.

316
00:15:21,750 --> 00:15:24,510
So I could write the
table of all answers.

317
00:15:24,510 --> 00:15:28,430
This is another way to
write down such a function.

318
00:15:28,430 --> 00:15:32,110
What we have, here, is an
infinite string of bits.

319
00:15:32,110 --> 00:15:34,290
Each of them could be 0 or 1.

320
00:15:34,290 --> 00:15:36,810
It would be a different problem.

321
00:15:36,810 --> 00:15:37,850
But they all exist.

322
00:15:37,850 --> 00:15:41,060
Any infinite string of bits
represents a decision problem.

323
00:15:41,060 --> 00:15:42,750
They're the same thing.

324
00:15:42,750 --> 00:15:45,950
So a decision problem is
an infinite string of bits.

325
00:15:45,950 --> 00:15:49,676
A program is a finite
string of bits.

326
00:15:49,676 --> 00:15:52,260
These are different things.

327
00:15:52,260 --> 00:15:54,170
One way to see that
they're different

328
00:15:54,170 --> 00:15:57,640
is put a decimal point, here.

329
00:15:57,640 --> 00:15:59,630
Now, this infinite
string of bits

330
00:15:59,630 --> 00:16:03,710
is a number-- a real
number-- between 0 and 1.

331
00:16:03,710 --> 00:16:04,720
It's written in binary.

332
00:16:04,720 --> 00:16:07,627
You may not be used
to binary point.

333
00:16:07,627 --> 00:16:08,960
This dot is not a decimal point.

334
00:16:08,960 --> 00:16:10,180
It's a binary point.

335
00:16:10,180 --> 00:16:12,970
But, hey.

336
00:16:12,970 --> 00:16:16,040
Any real number can be expressed
by an infinite string of bits

337
00:16:16,040 --> 00:16:18,820
in this way-- any real
number between 0 and 1.

338
00:16:18,820 --> 00:16:22,210

339
00:16:22,210 --> 00:16:31,940
So a decision
problem is basically

340
00:16:31,940 --> 00:16:35,260
something in R, the set
of all real numbers,

341
00:16:35,260 --> 00:16:38,555
whereas a program is something
in N, the set of all integers.

342
00:16:38,555 --> 00:16:41,750

343
00:16:41,750 --> 00:16:45,360
And the thing is, the
number of real numbers

344
00:16:45,360 --> 00:16:50,460
is much, much bigger than
the number of integers.

345
00:16:50,460 --> 00:16:53,110
In a formal sense, we call
this one uncountably infinite,

346
00:16:53,110 --> 00:16:55,060
and this one is
countably infinite.

347
00:16:55,060 --> 00:16:56,830
I'm not going to prove
that here, today.

348
00:16:56,830 --> 00:16:59,010
You may have seen that proof.

349
00:16:59,010 --> 00:17:01,320
It's pretty simple.

350
00:17:01,320 --> 00:17:02,350
And that's bad news.

351
00:17:02,350 --> 00:17:04,829
That means that there
are way more problems

352
00:17:04,829 --> 00:17:07,550
than there are
programs to solve them.

353
00:17:07,550 --> 00:17:12,890
So this means almost every
problem that we could conceive

354
00:17:12,890 --> 00:17:16,525
of is unsolvable
by every program.

355
00:17:16,525 --> 00:17:30,600

356
00:17:30,600 --> 00:17:33,245
And this is pretty depressing
the first time I saw it.

357
00:17:33,245 --> 00:17:35,120
That's why we put it at
the end of the class.

358
00:17:35,120 --> 00:17:37,950

359
00:17:37,950 --> 00:17:40,160
I think you get all existential.

360
00:17:40,160 --> 00:17:42,040
I mean the thing is
every program only

361
00:17:42,040 --> 00:17:43,201
solves one problem.

362
00:17:43,201 --> 00:17:44,700
It takes some input,
and it's either

363
00:17:44,700 --> 00:17:46,247
going to output yes or no.

364
00:17:46,247 --> 00:17:48,580
And if it's wrong on any of
the inputs, then it's wrong.

365
00:17:48,580 --> 00:17:51,010
So it's going to give an answer.

366
00:17:51,010 --> 00:17:52,570
Say it's a
deterministic algorithm.

367
00:17:52,570 --> 00:17:55,950
No random numbers or things.

368
00:17:55,950 --> 00:17:57,670
Then, there's just
not enough programs

369
00:17:57,670 --> 00:18:01,402
to go around if each program
only solves one problem.

370
00:18:01,402 --> 00:18:02,610
This is the end of the proof.

371
00:18:02,610 --> 00:18:05,110
Any questions about that?

372
00:18:05,110 --> 00:18:07,390
Kind of weird.

373
00:18:07,390 --> 00:18:10,390
Because yet somehow, most of
the problems that we think about

374
00:18:10,390 --> 00:18:11,530
are computable.

375
00:18:11,530 --> 00:18:13,100
I don't know why that is.

376
00:18:13,100 --> 00:18:15,520
But mathematically,
most problems

377
00:18:15,520 --> 00:18:17,425
that you could think
of are uncomputable.

378
00:18:17,425 --> 00:18:21,450

379
00:18:21,450 --> 00:18:22,974
Question?

380
00:18:22,974 --> 00:18:23,890
AUDIENCE: [INAUDIBLE].

381
00:18:23,890 --> 00:18:27,850

382
00:18:27,850 --> 00:18:28,750
PROFESSOR: Yeah.

383
00:18:28,750 --> 00:18:32,270
It's something like,
the way that we describe

384
00:18:32,270 --> 00:18:35,990
problems is usually almost
algorithmic, anyway.

385
00:18:35,990 --> 00:18:39,610
And so, usually, most problems
we think of are in EXP.

386
00:18:39,610 --> 00:18:42,300
And so they're
definitely computable.

387
00:18:42,300 --> 00:18:43,820
There's some
metatheorem about how

388
00:18:43,820 --> 00:18:46,385
we think about problems,
not just programs.

389
00:18:46,385 --> 00:18:51,110

390
00:18:51,110 --> 00:18:53,970
So that's all I'm going to
say about R. So out here,

391
00:18:53,970 --> 00:18:57,972
we have halting problem and,
actually, most problems.

392
00:18:57,972 --> 00:18:59,680
You can think of this
as an infinite line

393
00:18:59,680 --> 00:19:01,980
and then there's just
this small portion

394
00:19:01,980 --> 00:19:03,840
which are things you can solve.

395
00:19:03,840 --> 00:19:05,880
But we care about this
portion because that's

396
00:19:05,880 --> 00:19:07,040
the interesting stuff.

397
00:19:07,040 --> 00:19:08,750
That's what
algorithms are about.

398
00:19:08,750 --> 00:19:13,560
Out here kind of
nothing happens.

399
00:19:13,560 --> 00:19:17,070
So I want to talk about
this notch, which is NP.

400
00:19:17,070 --> 00:19:22,747

401
00:19:22,747 --> 00:19:24,080
I imagine you've heard about NP.

402
00:19:24,080 --> 00:19:27,252

403
00:19:27,252 --> 00:19:30,240
It's pretty cool, but
also kind of confusing.

404
00:19:30,240 --> 00:19:34,616

405
00:19:34,616 --> 00:19:37,890
But it's actually very
closely related to something

406
00:19:37,890 --> 00:19:42,320
we've seen with dynamic
programming, which is guessing.

407
00:19:42,320 --> 00:19:44,460
So I'm going to give you
a couple of definitions

408
00:19:44,460 --> 00:19:48,285
of NP-- not formal definition,
but high level definitions.

409
00:19:48,285 --> 00:19:52,210

410
00:19:52,210 --> 00:19:57,350
So just like P, EXP, and R,
it's a set of decision problems.

411
00:19:57,350 --> 00:20:03,650
And it's going to look very
similar to P. NP does not

412
00:20:03,650 --> 00:20:05,640
stand for not a polynomial.

413
00:20:05,640 --> 00:20:08,750
It stands for
nondeterministic polynomial.

414
00:20:08,750 --> 00:20:12,330
We'll get to
nondeterministic in a moment.

415
00:20:12,330 --> 00:20:14,436
The first line is the same.

416
00:20:14,436 --> 00:20:17,740
It's all decision problems you
can solve in polynomial time.

417
00:20:17,740 --> 00:20:19,720
That sounds like P.
But then, there's

418
00:20:19,720 --> 00:20:25,480
this extra line, which is
via a "lucky" algorithm.

419
00:20:25,480 --> 00:20:33,730

420
00:20:33,730 --> 00:20:36,840
Let me tell you--
at a high level what

421
00:20:36,840 --> 00:20:40,434
a lucky algorithm does
is it can make guesses.

422
00:20:40,434 --> 00:20:42,475
But unlike the way that
we've been making guesses

423
00:20:42,475 --> 00:20:44,360
with dynamic programming--
with dynamic programming

424
00:20:44,360 --> 00:20:45,443
we had to guess something.

425
00:20:45,443 --> 00:20:47,190
We tried all the possibilities.

426
00:20:47,190 --> 00:20:50,597
A lucky algorithm just
needs to try one possibility

427
00:20:50,597 --> 00:20:51,680
because it's really lucky.

428
00:20:51,680 --> 00:20:54,860
It always guesses
the right choice.

429
00:20:54,860 --> 00:20:56,440
It's like magic.

430
00:20:56,440 --> 00:20:59,310
This is not a realistic
model of computation,

431
00:20:59,310 --> 00:21:04,470
but it is a model of computation
called nondeterministic model.

432
00:21:04,470 --> 00:21:09,040

433
00:21:09,040 --> 00:21:11,950
And it's going to sound
crazy because it is crazy,

434
00:21:11,950 --> 00:21:15,080
but nonetheless it's
actually really useful--

435
00:21:15,080 --> 00:21:17,410
even though you could
never really build

436
00:21:17,410 --> 00:21:19,576
this on a real computer.

437
00:21:19,576 --> 00:21:20,950
The nondeterministic
model is not

438
00:21:20,950 --> 00:21:22,116
a model of real computation.

439
00:21:22,116 --> 00:21:25,410
It is a model of theoretical
hypothetical computation.

440
00:21:25,410 --> 00:21:27,300
It gets at the
root-- at the core

441
00:21:27,300 --> 00:21:29,730
of what is possible to solve.

442
00:21:29,730 --> 00:21:32,800
You'll see why, in a little bit.

443
00:21:32,800 --> 00:21:39,800
So in this model, an algorithm--
it can compute stuff,

444
00:21:39,800 --> 00:21:43,682
but, in particular,
it makes guesses.

445
00:21:43,682 --> 00:21:46,030
So should I do this
or should I do this?

446
00:21:46,030 --> 00:21:48,790
And it just says-- It
doesn't flip a coin.

447
00:21:48,790 --> 00:21:50,010
It's not random.

448
00:21:50,010 --> 00:21:53,990
It just thinks-- it
just makes a guess.

449
00:21:53,990 --> 00:21:54,800
Well, I don't know.

450
00:21:54,800 --> 00:21:56,390
Let's go this way.

451
00:21:56,390 --> 00:21:58,182
And then it comes
another fork in the road.

452
00:21:58,182 --> 00:21:59,431
It's like, well, I don't know.

453
00:21:59,431 --> 00:22:00,410
I'll go this way.

454
00:22:00,410 --> 00:22:01,660
That's the guessing.

455
00:22:01,660 --> 00:22:04,160
You give it a list of
choices and somehow a choice

456
00:22:04,160 --> 00:22:08,910
is determined, by magic--
nondeterministic magic.

457
00:22:08,910 --> 00:22:18,970
And then the fun part is--
I should say, at the end

458
00:22:18,970 --> 00:22:24,652
the algorithm either
says yes or no.

459
00:22:24,652 --> 00:22:25,610
It gives you an output.

460
00:22:25,610 --> 00:22:28,420

461
00:22:28,420 --> 00:22:34,590
The guesses are guaranteed--
this is the magic part--

462
00:22:34,590 --> 00:22:43,780
to lead to a yes
answer, if possible.

463
00:22:43,780 --> 00:22:47,650

464
00:22:47,650 --> 00:22:50,800
So if you imagine the space
of executions of this program,

465
00:22:50,800 --> 00:22:53,342
you start here, and you
make some guess and you

466
00:22:53,342 --> 00:22:55,190
don't know which way to go.

467
00:22:55,190 --> 00:22:57,119
In dynamic programming,
we try all of them.

468
00:22:57,119 --> 00:22:58,910
But this algorithm
doesn't try all of them.

469
00:22:58,910 --> 00:23:01,580
It's like a branching universe
model of the universe.

470
00:23:01,580 --> 00:23:03,930
So you make some
choice, and then you

471
00:23:03,930 --> 00:23:06,430
make some other choice, and
then you make some other choice.

472
00:23:06,430 --> 00:23:08,900
All of these are guesses.

473
00:23:08,900 --> 00:23:11,500
And some of these
things will lead to yes.

474
00:23:11,500 --> 00:23:13,120
Some of these things
will lead to no.

475
00:23:13,120 --> 00:23:17,040
And in this magical model,
if there's any yes out there,

476
00:23:17,040 --> 00:23:19,660
you will follow a path to a yes.

477
00:23:19,660 --> 00:23:21,974
If all of the answers
are no, then, of course,

478
00:23:21,974 --> 00:23:23,640
it doesn't matter
what choices you make.

479
00:23:23,640 --> 00:23:25,100
You will output no.

480
00:23:25,100 --> 00:23:27,940
But if there's ever a yes,
magically these guesses

481
00:23:27,940 --> 00:23:28,580
find it.

482
00:23:28,580 --> 00:23:30,390
This is the sense of lucky.

483
00:23:30,390 --> 00:23:33,940
If you're trying to find a
yes-- that's your goal in life--

484
00:23:33,940 --> 00:23:37,290
then this corresponds to luck.

485
00:23:37,290 --> 00:23:40,260
And NP is the class of
all problems solvable

486
00:23:40,260 --> 00:23:43,800
in polynomial time by a
really lucky algorithm.

487
00:23:43,800 --> 00:23:44,850
Crazy.

488
00:23:44,850 --> 00:23:45,350
I know.

489
00:23:45,350 --> 00:23:50,450

490
00:23:50,450 --> 00:23:53,115
Let's talk about Tetris.

491
00:23:53,115 --> 00:23:56,320

492
00:23:56,320 --> 00:23:59,871
Tetris, I claim, is in NP.

493
00:23:59,871 --> 00:24:01,870
And we know how to solve
it in exponential time.

494
00:24:01,870 --> 00:24:04,280
Just try all the options.

495
00:24:04,280 --> 00:24:07,640
But, in fact, I don't need
to try all the options.

496
00:24:07,640 --> 00:24:11,150
It would be enough just use
this nondeterministic magic.

497
00:24:11,150 --> 00:24:14,420
I could say, well, should I
drop the piece here, here, here,

498
00:24:14,420 --> 00:24:15,739
here, here, or here.

499
00:24:15,739 --> 00:24:17,780
And should it be rotated
like this, or like this,

500
00:24:17,780 --> 00:24:20,170
or like this, or like this?

501
00:24:20,170 --> 00:24:20,910
I don't know.

502
00:24:20,910 --> 00:24:22,210
So I guess.

503
00:24:22,210 --> 00:24:23,775
And I just place that piece.

504
00:24:23,775 --> 00:24:25,900
I make another guess where
to place the next piece.

505
00:24:25,900 --> 00:24:27,550
Then I make another guess
where to place the next piece.

506
00:24:27,550 --> 00:24:29,520
I implement the rules
of Tetris, which

507
00:24:29,520 --> 00:24:32,426
is if there's a
full line it clears.

508
00:24:32,426 --> 00:24:34,980
I figure out where
these things fall.

509
00:24:34,980 --> 00:24:39,080
I can even think about, should
I rotate at the last second.

510
00:24:39,080 --> 00:24:41,894
If I don't know, I'll guess.

511
00:24:41,894 --> 00:24:43,810
Any choice you have to
make in playing Tetris,

512
00:24:43,810 --> 00:24:45,280
you can just guess.

513
00:24:45,280 --> 00:24:47,660
There's only polynomially
many guesses you need to make.

514
00:24:47,660 --> 00:24:49,600
So it's still polynomial time.

515
00:24:49,600 --> 00:24:50,440
That's important.

516
00:24:50,440 --> 00:24:52,060
It's not like we
can do anything.

517
00:24:52,060 --> 00:24:54,770
But we can make a polynomial
number these magic guesses.

518
00:24:54,770 --> 00:24:59,330
And then at the end, I
determine did I die--

519
00:24:59,330 --> 00:25:01,070
or rather, did I survive.

520
00:25:01,070 --> 00:25:02,120
It's important, actually.

521
00:25:02,120 --> 00:25:03,980
It only works one way.

522
00:25:03,980 --> 00:25:04,780
Did I survive?

523
00:25:04,780 --> 00:25:05,555
Yes or no?

524
00:25:05,555 --> 00:25:06,680
And that's easy to compute.

525
00:25:06,680 --> 00:25:11,120
I just see did I ever
go above the top row.

526
00:25:11,120 --> 00:25:13,640
So what this model says
is if there is any way

527
00:25:13,640 --> 00:25:17,100
to survive-- if there is
any way to get a yes answer,

528
00:25:17,100 --> 00:25:21,220
then, my guesses will find
it, magically, in this model.

529
00:25:21,220 --> 00:25:22,370
Therefore, Tetris is in NP.

530
00:25:22,370 --> 00:25:24,980

531
00:25:24,980 --> 00:25:28,200
If I had instead
said, did I die, then,

532
00:25:28,200 --> 00:25:31,120
what this algorithm would
tell me is there any way

533
00:25:31,120 --> 00:25:33,970
to die-- which, the
answer's probably yes,

534
00:25:33,970 --> 00:25:36,360
unless you're given a
really trivial input.

535
00:25:36,360 --> 00:25:39,710
So it's important you set up
the yes versus no, correctly.

536
00:25:39,710 --> 00:25:43,980
But the Tetris decision problem
"can I survive," is in NP.

537
00:25:43,980 --> 00:25:48,670
The decision problem "can I
die," should not be in NP.

538
00:25:48,670 --> 00:25:49,494
But we don't know.

539
00:25:49,494 --> 00:25:57,110

540
00:25:57,110 --> 00:25:58,430
Another way to think about NP.

541
00:25:58,430 --> 00:26:01,382

542
00:26:01,382 --> 00:26:02,950
And you might find
this intuitive

543
00:26:02,950 --> 00:26:04,800
because we've been
doing lots of guessing.

544
00:26:04,800 --> 00:26:06,330
It's just a little crazy.

545
00:26:06,330 --> 00:26:11,490
There's another way that's
more intuitive to many people.

546
00:26:11,490 --> 00:26:14,520
So if this doesn't make
sense, don't worry, yet.

547
00:26:14,520 --> 00:26:16,110
This is another
way to phrase it.

548
00:26:16,110 --> 00:26:53,152

549
00:26:53,152 --> 00:26:55,110
Another way to think
about NP-- which turns out

550
00:26:55,110 --> 00:27:01,450
to be equivalent-- is that don't
think so much about algorithms

551
00:27:01,450 --> 00:27:04,300
for solving a problem,
just think about algorithms

552
00:27:04,300 --> 00:27:07,437
for checking the
solution to a problem.

553
00:27:07,437 --> 00:27:09,270
It's usually a lot
easier to check your work

554
00:27:09,270 --> 00:27:11,980
than it is to solve a
problem in the first place.

555
00:27:11,980 --> 00:27:15,400
And NP is all about that issue.

556
00:27:15,400 --> 00:27:17,540
So think of decision
problems and think

557
00:27:17,540 --> 00:27:21,270
about if you have a solution--
so let's say in Tetris,

558
00:27:21,270 --> 00:27:24,790
the solution is yes.

559
00:27:24,790 --> 00:27:27,660
In fact, I need to
say this, probably.

560
00:27:27,660 --> 00:27:31,150
The more formal
version is whenever

561
00:27:31,150 --> 00:27:37,900
the answer is yes,
you can prove it.

562
00:27:37,900 --> 00:27:41,880

563
00:27:41,880 --> 00:27:44,100
And you can check that
proof in polynomial time.

564
00:27:44,100 --> 00:27:49,890

565
00:27:49,890 --> 00:27:53,140
This is the more formal--
this a little bit high level.

566
00:27:53,140 --> 00:27:54,130
What does check mean?

567
00:27:54,130 --> 00:27:56,080
Here's what check means.

568
00:27:56,080 --> 00:27:59,560
Whenever an answer is "yes,"
you can write down a proof

569
00:27:59,560 --> 00:28:00,900
that the answer is yes.

570
00:28:00,900 --> 00:28:02,400
And someone can
come along and check

571
00:28:02,400 --> 00:28:04,370
that proof in polynomial
time and be convinced

572
00:28:04,370 --> 00:28:06,310
that the answer is yes.

573
00:28:06,310 --> 00:28:07,600
What does convinced mean?

574
00:28:07,600 --> 00:28:09,800
It's not that hard.

575
00:28:09,800 --> 00:28:11,660
Think of it is a
two player game.

576
00:28:11,660 --> 00:28:13,400
There's me trying
to play Tetris,

577
00:28:13,400 --> 00:28:15,400
and there's you
trying to be convinced

578
00:28:15,400 --> 00:28:18,100
that I'm really good at Tetris.

579
00:28:18,100 --> 00:28:23,060
It seems a little one sided,
but-- it's a asymmetric game.

580
00:28:23,060 --> 00:28:27,420
So you want to prove Tetris is--
I want to show Tetris is in NP.

581
00:28:27,420 --> 00:28:29,790
Imagine I'm this
magical creature.

582
00:28:29,790 --> 00:28:31,160
Actually, it's kind of funny.

583
00:28:31,160 --> 00:28:32,680
It reminds me of a story.

584
00:28:32,680 --> 00:28:34,620
On the front of my
office door, you

585
00:28:34,620 --> 00:28:37,540
may have seen there's
an email I received,

586
00:28:37,540 --> 00:28:39,900
maybe 15 years
ago-- oh no, I guess

587
00:28:39,900 --> 00:28:42,100
it can't be that long ago.

588
00:28:42,100 --> 00:28:43,710
Must've been about
7 years ago when

589
00:28:43,710 --> 00:28:47,040
we proved that Tetris
is NP-complete.

590
00:28:47,040 --> 00:28:51,660
And the email says, "Dear
Sir,"-- or whatever--

591
00:28:51,660 --> 00:28:54,349
"I am NP-complete."

592
00:28:54,349 --> 00:28:55,890
We don't what
NP-complete means, yet,

593
00:28:55,890 --> 00:28:57,310
but it's a
meaningless statement.

594
00:28:57,310 --> 00:28:59,640
So it doesn't matter that
you don't know what it means.

595
00:28:59,640 --> 00:29:03,940
It might get funnier
throughout the lecture today.

596
00:29:03,940 --> 00:29:07,860
And he's like, I
can solve Tetris.

597
00:29:07,860 --> 00:29:09,534
I'm really good
at playing Tetris.

598
00:29:09,534 --> 00:29:11,200
I'm really good at
playing Minesweeper--

599
00:29:11,200 --> 00:29:14,210
all these games that are
thought to be intractable.

600
00:29:14,210 --> 00:29:15,810
He gave me his
records and so on.

601
00:29:15,810 --> 00:29:20,230
It's like how can
I apply my talent.

602
00:29:20,230 --> 00:29:26,230
So I will translate what he
meant to say was, "I am lucky."

603
00:29:26,230 --> 00:29:29,017
And this is probably
not true, but he

604
00:29:29,017 --> 00:29:30,100
thought that he was lucky.

605
00:29:30,100 --> 00:29:31,940
He wanted to convince
me he was lucky.

606
00:29:31,940 --> 00:29:33,610
So how could we do it?

607
00:29:33,610 --> 00:29:36,540
Well, I could give him a
really hard Tetris problem.

608
00:29:36,540 --> 00:29:38,870
And say, can you
survive these pieces?

609
00:29:38,870 --> 00:29:41,450
And he says, "yes,
I can survive. "

610
00:29:41,450 --> 00:29:43,450
And how does he prove to
me that he can survive?

611
00:29:43,450 --> 00:29:45,150
Well, he just plays it.

612
00:29:45,150 --> 00:29:47,420
He shows me what to do.

613
00:29:47,420 --> 00:29:53,740
So proof is sequence
of moves that you make.

614
00:29:53,740 --> 00:29:55,870
It's really easy
to convince someone

615
00:29:55,870 --> 00:30:00,290
that you can survive a
given level of Tetris.

616
00:30:00,290 --> 00:30:04,380
You just show what the
sequence of moves are.

617
00:30:04,380 --> 00:30:07,860
And then I, as a mere mortal
polynomial time algorithm

618
00:30:07,860 --> 00:30:09,780
can check that that
sequence works.

619
00:30:09,780 --> 00:30:12,064
I just have to implement
the rules of Tetris.

620
00:30:12,064 --> 00:30:13,980
So in Tetris, the rules
are easy to implement.

621
00:30:13,980 --> 00:30:18,120
Its the knowing what
thing to do is hard.

622
00:30:18,120 --> 00:30:21,840
But in NP, knowing
which way to go is easy.

623
00:30:21,840 --> 00:30:23,340
In this version,
you don't even talk

624
00:30:23,340 --> 00:30:24,820
about how to find the solution.

625
00:30:24,820 --> 00:30:26,486
It's just a matter
of can you write down

626
00:30:26,486 --> 00:30:29,280
a solution that can be checked.

627
00:30:29,280 --> 00:30:30,000
Can prove it.

628
00:30:30,000 --> 00:30:31,420
This is not in polynomial time.

629
00:30:31,420 --> 00:30:34,710
You get arbitrarily
much time to prove it.

630
00:30:34,710 --> 00:30:37,540
But then, the check has to
happen in polynomial time.

631
00:30:37,540 --> 00:30:41,047

632
00:30:41,047 --> 00:30:41,630
Kind of clear?

633
00:30:41,630 --> 00:30:44,290

634
00:30:44,290 --> 00:30:46,450
That's Tetris.

635
00:30:46,450 --> 00:30:49,220
And every problem that you
can solve in polynomial

636
00:30:49,220 --> 00:30:51,049
time you can also,
of course, check it.

637
00:30:51,049 --> 00:30:53,090
Because if you could solve
it in polynomial time,

638
00:30:53,090 --> 00:30:54,590
you could just solve
it and then see

639
00:30:54,590 --> 00:30:56,320
did you get the same
answer that I did.

640
00:30:56,320 --> 00:30:59,790
So P is inside NP.

641
00:30:59,790 --> 00:31:04,910
But the big question
is does p equal NP.

642
00:31:04,910 --> 00:31:08,600
And most people think no.

643
00:31:08,600 --> 00:31:12,060
P does not equal NP--
most sane people.

644
00:31:12,060 --> 00:31:16,690

645
00:31:16,690 --> 00:31:18,910
So this is a big problem.

646
00:31:18,910 --> 00:31:21,900
It's one of the famous
Millennium Prize problems.

647
00:31:21,900 --> 00:31:27,030
So in particular, if you solved
it, you would get $1 million,

648
00:31:27,030 --> 00:31:29,080
and fame, and probably
other fortune.

649
00:31:29,080 --> 00:31:31,060
You could do TV spots.

650
00:31:31,060 --> 00:31:34,160
I think that's how people
mostly make their money.

651
00:31:34,160 --> 00:31:35,280
You could do a lot.

652
00:31:35,280 --> 00:31:38,020
You would become the most famous
computer scientist in the world

653
00:31:38,020 --> 00:31:40,020
if you prove this.

654
00:31:40,020 --> 00:31:41,270
So a lot of people have tried.

655
00:31:41,270 --> 00:31:44,070
Every year, there's an
attempt to prove either

656
00:31:44,070 --> 00:31:46,500
what everyone believes
or, most often,

657
00:31:46,500 --> 00:31:49,742
people try to prove the
reverse-- that they are equal.

658
00:31:49,742 --> 00:31:50,450
I don't know why.

659
00:31:50,450 --> 00:31:53,250
They should bet the other way.

660
00:31:53,250 --> 00:31:55,360
So what does P does
not equal NP mean?

661
00:31:55,360 --> 00:32:00,040
It means that there are
problems, here, that are in NP

662
00:32:00,040 --> 00:32:03,240
but not in P. Think
about what this means.

663
00:32:03,240 --> 00:32:05,810
This is saying P are the
problems that we can actually

664
00:32:05,810 --> 00:32:07,680
solve on a legitimate computer.

665
00:32:07,680 --> 00:32:10,950
NP are problems that we can
solve in this magical fairy

666
00:32:10,950 --> 00:32:14,370
computer where all of
our dreams are granted.

667
00:32:14,370 --> 00:32:16,120
You say, oh, I don't
know which way to go.

668
00:32:16,120 --> 00:32:19,510
It doesn't matter because
the machine magically

669
00:32:19,510 --> 00:32:21,400
tells you which way to go.

670
00:32:21,400 --> 00:32:24,210
If you're goal is
to get to a yes.

671
00:32:24,210 --> 00:32:27,930
So NP is a really powerful
model of computation.

672
00:32:27,930 --> 00:32:29,690
It's an insane model
of computation.

673
00:32:29,690 --> 00:32:32,100
No one in their right mind
would consider it legitimate.

674
00:32:32,100 --> 00:32:35,250
So obviously, it's
more powerful than P,

675
00:32:35,250 --> 00:32:37,727
except we don't know
how to prove it.

676
00:32:37,727 --> 00:32:38,310
Very annoying.

677
00:32:38,310 --> 00:32:45,480

678
00:32:45,480 --> 00:32:47,450
Other phrasings of
P does not equal

679
00:32:47,450 --> 00:32:50,870
NP is-- these are my
phrasings, I them up-- you

680
00:32:50,870 --> 00:32:53,090
can't engineer luck.

681
00:32:53,090 --> 00:32:57,520

682
00:32:57,520 --> 00:32:59,160
You can believe in
luck, if you want.

683
00:32:59,160 --> 00:33:01,410
But it's not something
that we can build out

684
00:33:01,410 --> 00:33:03,960
of a regular computer.

685
00:33:03,960 --> 00:33:07,545
That's the meaning
of this statement.

686
00:33:07,545 --> 00:33:09,485
And so I think most
people believe that.

687
00:33:09,485 --> 00:33:13,530

688
00:33:13,530 --> 00:33:19,520
Another phrasing would
be that solving problems

689
00:33:19,520 --> 00:33:22,460
is harder than
checking solutions.

690
00:33:22,460 --> 00:33:27,300

691
00:33:27,300 --> 00:33:30,645
A more formal version is that
generating solutions or proofs

692
00:33:30,645 --> 00:33:37,510
of solutions can be
harder than checking them.

693
00:33:37,510 --> 00:33:44,850

694
00:33:44,850 --> 00:33:47,860
Another phrasing is
it's harder to generate

695
00:33:47,860 --> 00:33:49,550
a proof of a theorem
than it is to check

696
00:33:49,550 --> 00:33:50,780
the proof of a theorem.

697
00:33:50,780 --> 00:33:53,400
We all know checking
the proof of a theorem

698
00:33:53,400 --> 00:33:56,000
should be easy if you
write it precisely.

699
00:33:56,000 --> 00:33:58,420
Just make sure each step
follows from the previous ones.

700
00:33:58,420 --> 00:34:00,152
Done.

701
00:34:00,152 --> 00:34:01,610
But proving a
theorem, that's hard.

702
00:34:01,610 --> 00:34:02,550
You need inspiration.

703
00:34:02,550 --> 00:34:03,740
You need some clever idea.

704
00:34:03,740 --> 00:34:04,920
That's guessing.

705
00:34:04,920 --> 00:34:09,020
Inspiration equals luck equals
guessing, in this model.

706
00:34:09,020 --> 00:34:10,370
And that's hard.

707
00:34:10,370 --> 00:34:13,380

708
00:34:13,380 --> 00:34:15,880
The only way we know is
to try all the proofs.

709
00:34:15,880 --> 00:34:17,270
See which of them work.

710
00:34:17,270 --> 00:34:24,020

711
00:34:24,020 --> 00:34:26,350
So what the heck?

712
00:34:26,350 --> 00:34:27,510
What could we possibly say?

713
00:34:27,510 --> 00:34:30,020
This is all kind of weird.

714
00:34:30,020 --> 00:34:31,520
This would be the
end of the lecture

715
00:34:31,520 --> 00:34:34,770
if you say, OK,
well we don't know.

716
00:34:34,770 --> 00:34:37,350
That's it.

717
00:34:37,350 --> 00:34:41,524
But thankfully-- I kind
of need this board.

718
00:34:41,524 --> 00:34:43,690
I also want this one, but
I guess I'll go over here.

719
00:34:43,690 --> 00:34:48,364

720
00:34:48,364 --> 00:34:50,280
Fortunately, this is not
the end of the story.

721
00:34:50,280 --> 00:34:55,340
And we can say a lot
about things like Tetris.

722
00:34:55,340 --> 00:34:57,930
See I drew Tetris not
just in this regime.

723
00:34:57,930 --> 00:35:01,330
We're pretty sure Tetris
is between NP and P.

724
00:35:01,330 --> 00:35:06,480
That it's in NP minus P.

725
00:35:06,480 --> 00:35:08,830
So let me write that down.

726
00:35:08,830 --> 00:35:16,640
Tetris is in NP minus P. We
don't know that because we

727
00:35:16,640 --> 00:35:20,070
don't know-- this
could be the empty set.

728
00:35:20,070 --> 00:35:26,040
What we do know
is that if there's

729
00:35:26,040 --> 00:35:32,040
anything in NP minus P--
if they are different,

730
00:35:32,040 --> 00:35:35,900
then-- if there's
anything in NP minus P,

731
00:35:35,900 --> 00:35:39,060
then Tetris is one
of those things.

732
00:35:39,060 --> 00:35:40,760
That's why I drew
Tetris out there.

733
00:35:40,760 --> 00:35:45,800
It is, in a certain sense,
the hardest problem in NP.

734
00:35:45,800 --> 00:35:47,690
Tetris.

735
00:35:47,690 --> 00:35:49,550
Why Tetris?

736
00:35:49,550 --> 00:35:50,809
Well, it's not just Tetris.

737
00:35:50,809 --> 00:35:53,100
There are a lot of problems
right at that little notch.

738
00:35:53,100 --> 00:35:57,220
But this is pretty interesting
because, while we can't figure

739
00:35:57,220 --> 00:35:59,920
this out, most people
believe this is true.

740
00:35:59,920 --> 00:36:01,982
And so as long as you
believe in that-- as long

741
00:36:01,982 --> 00:36:05,920
as you have faith--
then you can prove

742
00:36:05,920 --> 00:36:08,160
that Tetris is in NP minus P.

743
00:36:08,160 --> 00:36:09,650
And so it's hard.

744
00:36:09,650 --> 00:36:11,880
It's not in P, in this case.

745
00:36:11,880 --> 00:36:19,739
In particular, not in
P. That's kind of cool.

746
00:36:19,739 --> 00:36:21,780
How in the world do we
prove something like this?

747
00:36:21,780 --> 00:36:23,910
It's actually not that hard.

748
00:36:23,910 --> 00:36:25,830
I mean it took us
several months,

749
00:36:25,830 --> 00:36:29,640
but that's just months, whereas
this thing has been around

750
00:36:29,640 --> 00:36:33,170
since, I guess, the '70s.

751
00:36:33,170 --> 00:36:36,030
P versus NP.

752
00:36:36,030 --> 00:36:38,760
Why is this true?

753
00:36:38,760 --> 00:36:42,960
Because Tetris is NP-hard.

754
00:36:42,960 --> 00:36:46,210

755
00:36:46,210 --> 00:36:48,420
What does NP-hard mean?

756
00:36:48,420 --> 00:36:54,640
This means as hard as
every problem in NP.

757
00:36:54,640 --> 00:36:59,340

758
00:36:59,340 --> 00:37:02,010
I can't say harder than
because it's non-strict.

759
00:37:02,010 --> 00:37:04,910
So it's at least as hard
as every problem in NP.

760
00:37:04,910 --> 00:37:07,580
And that's why I drew
it at the far right.

761
00:37:07,580 --> 00:37:10,340
It's sort of the
hardest extreme of NP.

762
00:37:10,340 --> 00:37:13,030
Among everything in NP
you can possibly imagine,

763
00:37:13,030 --> 00:37:16,000
Tetris is as hard
as all of them.

764
00:37:16,000 --> 00:37:19,430
And therefore, if there's
anything that's harder than P,

765
00:37:19,430 --> 00:37:22,350
then Tetris is going to be
harder than P because it's

766
00:37:22,350 --> 00:37:23,700
as far to the right as possible.

767
00:37:23,700 --> 00:37:27,490
Either P equals NP, in which
case the picture is like this.

768
00:37:27,490 --> 00:37:29,920
Here's P. Here's NP.

769
00:37:29,920 --> 00:37:32,300
Tetris is still at the
right extreme, here.

770
00:37:32,300 --> 00:37:35,430
But it's less interesting
because it's still in P.

771
00:37:35,430 --> 00:37:37,590
Or the picture looks like
this, and NP is strictly

772
00:37:37,590 --> 00:37:41,020
bigger than P. And then, because
Tetris is at the right extreme,

773
00:37:41,020 --> 00:37:45,290
it's outside of P. So
we prove this in order

774
00:37:45,290 --> 00:37:47,110
to establish this claim.

775
00:37:47,110 --> 00:37:51,010

776
00:37:51,010 --> 00:37:52,630
Just to get some
terminology, what

777
00:37:52,630 --> 00:37:53,940
is this NP-complete business?

778
00:37:53,940 --> 00:37:58,810

779
00:37:58,810 --> 00:38:09,550
Tetris is NP-complete,
which means two things.

780
00:38:09,550 --> 00:38:11,470
One is that it's NP-hard.

781
00:38:11,470 --> 00:38:13,960
And the other is
that it's in NP.

782
00:38:13,960 --> 00:38:16,340
So if you think of the
intersection, NP intersect

783
00:38:16,340 --> 00:38:18,210
NP-hard, that's NP-complete.

784
00:38:18,210 --> 00:38:26,490
Let me draw on the picture
here what this means.

785
00:38:26,490 --> 00:38:28,140
So I'm going to
draw it on the top.

786
00:38:28,140 --> 00:38:38,590

787
00:38:38,590 --> 00:38:39,720
This is NP-hard.

788
00:38:39,720 --> 00:38:42,390

789
00:38:42,390 --> 00:38:46,040
Everything from here to
the right is NP-hard.

790
00:38:46,040 --> 00:38:48,922
NP-hard means it's at least
as hard as everything in NP.

791
00:38:48,922 --> 00:38:50,380
That means it might
be at this line

792
00:38:50,380 --> 00:38:52,390
or it might be to the right.

793
00:38:52,390 --> 00:38:55,130
But in the case of Tetris,
we know that it's in NP.

794
00:38:55,130 --> 00:38:57,494
We proved that a
couple of times.

795
00:38:57,494 --> 00:38:59,535
And so we know that Tetris
is also in this range.

796
00:38:59,535 --> 00:39:01,850
And so if it's in this
range and in this range,

797
00:39:01,850 --> 00:39:03,690
it's got to be right here.

798
00:39:03,690 --> 00:39:04,940
Completeness is nice.

799
00:39:04,940 --> 00:39:07,370
If you prove something
is something complete--

800
00:39:07,370 --> 00:39:09,920
prove a problem is some
complexity class complete--

801
00:39:09,920 --> 00:39:13,550
then you know sort of exactly
where it falls on this line.

802
00:39:13,550 --> 00:39:15,750
NP-complete means right here.

803
00:39:15,750 --> 00:39:18,520
EXP-complete means right here.

804
00:39:18,520 --> 00:39:22,880
Turns out Chess is EXP-complete.

805
00:39:22,880 --> 00:39:27,710
EXP-hard is anything
from here over.

806
00:39:27,710 --> 00:39:30,670
EXP is anything from
here, over this way.

807
00:39:30,670 --> 00:39:32,335
Chess is right at
that borderline.

808
00:39:32,335 --> 00:39:34,512
It is the hardest
problem in EXP.

809
00:39:34,512 --> 00:39:35,970
And that's actually
the only way we

810
00:39:35,970 --> 00:39:37,970
know to prove that it's not NP.

811
00:39:37,970 --> 00:39:39,970
It's is pretty easy to
show that EXP is bigger

812
00:39:39,970 --> 00:39:43,770
than P. And Chess is the
farthest to the right in EXP--

813
00:39:43,770 --> 00:39:47,800
of any problem in EXP-- and
so, therefore, it's not in P.

814
00:39:47,800 --> 00:39:51,350
So whereas this one-- these two,
we're not sure are they equal.

815
00:39:51,350 --> 00:39:55,190
This line we know is
different from this one.

816
00:39:55,190 --> 00:39:58,720
We don't know about
these two, though.

817
00:39:58,720 --> 00:40:01,550
Does NP equal EXP?

818
00:40:01,550 --> 00:40:02,240
Not as famous.

819
00:40:02,240 --> 00:40:04,850
You won't get a million
dollars, but still a very big,

820
00:40:04,850 --> 00:40:07,550
open question.

821
00:40:07,550 --> 00:40:09,590
What else do I wanna say?

822
00:40:09,590 --> 00:40:11,020
Tetris, Chess, EXP-hard.

823
00:40:11,020 --> 00:40:16,369
So these lines, here--
this is NP-complete

824
00:40:16,369 --> 00:40:17,410
And this is EXP-complete.

825
00:40:17,410 --> 00:40:35,980

826
00:40:35,980 --> 00:40:39,015
So the last thing I want to
talk about is reductions.

827
00:40:39,015 --> 00:40:43,770

828
00:40:43,770 --> 00:40:45,980
Reductions-- so how do you
prove something like this?

829
00:40:45,980 --> 00:40:47,710
What is as hard as even mean?

830
00:40:47,710 --> 00:40:49,230
I haven't defined that.

831
00:40:49,230 --> 00:40:51,270
But it's not hard to define.

832
00:40:51,270 --> 00:40:53,130
In fact, it's a concept
we've seen already.

833
00:40:53,130 --> 00:41:18,610

834
00:41:18,610 --> 00:41:21,380
Reductions are actually a
way to design algorithms

835
00:41:21,380 --> 00:41:24,354
that we've been using
implicitly a lot.

836
00:41:24,354 --> 00:41:25,770
You may have even
heard this term.

837
00:41:25,770 --> 00:41:28,010
A bunch of recitations have
used the word reduction

838
00:41:28,010 --> 00:41:29,970
for graph reduction.

839
00:41:29,970 --> 00:41:31,770
You have some problem,
you convert it

840
00:41:31,770 --> 00:41:34,590
into a graph problem, then you
just call the graph algorithm.

841
00:41:34,590 --> 00:41:35,830
You're done.

842
00:41:35,830 --> 00:41:36,760
That's reduction.

843
00:41:36,760 --> 00:41:38,820
In general, you have
some problem, A,

844
00:41:38,820 --> 00:41:40,830
that you want to solve.

845
00:41:40,830 --> 00:41:44,030
And you convert it into
some other problem, B,

846
00:41:44,030 --> 00:41:46,182
that you already
know how to solve.

847
00:41:46,182 --> 00:41:47,890
It's a great tool
because, in this class,

848
00:41:47,890 --> 00:41:50,630
you learn tons of algorithms
for solving tons of problems.

849
00:41:50,630 --> 00:41:55,070
Now, someone gives you,
in your job or whatever,

850
00:41:55,070 --> 00:41:56,950
or you think about
some problem that you

851
00:41:56,950 --> 00:41:59,180
don't know how to solve,
the first thing you should

852
00:41:59,180 --> 00:42:01,000
do is-- can I convert
it into something

853
00:42:01,000 --> 00:42:02,930
I know how to solve
because then you're done.

854
00:42:02,930 --> 00:42:04,721
Now it may not be the
best way to solve it,

855
00:42:04,721 --> 00:42:06,410
but at least it's
a way to solve it.

856
00:42:06,410 --> 00:42:09,015
Probably in polynomial time
because we think of B as things

857
00:42:09,015 --> 00:42:10,390
you can solve in
polynomial time.

858
00:42:10,390 --> 00:42:13,160
Great.

859
00:42:13,160 --> 00:42:20,730
So just convert
problem A, which you

860
00:42:20,730 --> 00:42:27,615
want to solve, into some problem
B that you know how to solve.

861
00:42:27,615 --> 00:42:30,690

862
00:42:30,690 --> 00:42:32,370
That's reduction.

863
00:42:32,370 --> 00:42:35,460
Let me give you some examples
that we've already seen,

864
00:42:35,460 --> 00:42:38,065
just to fit this into your
mental map of the class.

865
00:42:38,065 --> 00:42:42,640

866
00:42:42,640 --> 00:42:45,060
It's kind of a funny one
but it's a very simple one.

867
00:42:45,060 --> 00:42:52,470

868
00:42:52,470 --> 00:42:54,460
So how do you solve
unweighted shortest paths?

869
00:42:54,460 --> 00:42:58,300

870
00:42:58,300 --> 00:42:59,810
In general?

871
00:42:59,810 --> 00:43:00,670
Easy one.

872
00:43:00,670 --> 00:43:02,794
Give you a graph with no
weights on the edges and I

873
00:43:02,794 --> 00:43:04,466
want to the shortest
path from s to t.

874
00:43:04,466 --> 00:43:05,390
AUDIENCE: BFS

875
00:43:05,390 --> 00:43:06,180
PROFESSOR: BFS.

876
00:43:06,180 --> 00:43:07,600
Linear time, right?

877
00:43:07,600 --> 00:43:10,050
Well, that's if
you're smart or if you

878
00:43:10,050 --> 00:43:11,250
feel like implementing BFS.

879
00:43:11,250 --> 00:43:14,380
Suppose someone
gave you Djikstra.

880
00:43:14,380 --> 00:43:16,125
Said, here, look, I've
got Djikstra code.

881
00:43:16,125 --> 00:43:17,375
You don't have to do anything.

882
00:43:17,375 --> 00:43:18,940
There's Djisktra
code right there.

883
00:43:18,940 --> 00:43:21,100
But Djikstra solves
weighted shortest path.

884
00:43:21,100 --> 00:43:22,160
I don't have any weights.

885
00:43:22,160 --> 00:43:24,960
What do I do?

886
00:43:24,960 --> 00:43:28,140
Set the weights to 1.

887
00:43:28,140 --> 00:43:30,630
It's very easy, but
this is a reduction--

888
00:43:30,630 --> 00:43:32,460
a simple example of reduction.

889
00:43:32,460 --> 00:43:35,330
Not the smartest of reductions,
but it's a reduction.

890
00:43:35,330 --> 00:43:38,840

891
00:43:38,840 --> 00:43:40,780
So I can convert
unweighted shortest paths

892
00:43:40,780 --> 00:43:43,750
into weighted shortest paths
by adding weights of 1.

893
00:43:43,750 --> 00:43:44,320
Done.

894
00:43:44,320 --> 00:43:46,070
Adding weights of
0 would not work.

895
00:43:46,070 --> 00:43:47,170
But weights of 1.

896
00:43:47,170 --> 00:43:47,900
OK.

897
00:43:47,900 --> 00:43:49,492
Weights of 2 also works.

898
00:43:49,492 --> 00:43:51,950
Pick your favorite number, but
as long as you're consistent

899
00:43:51,950 --> 00:43:52,780
about it.

900
00:43:52,780 --> 00:43:54,520
That's a reduction.

901
00:43:54,520 --> 00:43:56,570
Here's some more
interesting ones.

902
00:43:56,570 --> 00:44:03,920
On the problems set--
problem set six--

903
00:44:03,920 --> 00:44:08,205
there was this RenBook problem,
"I Can Haz Moar Frendz?"

904
00:44:08,205 --> 00:44:09,580
That was the name
of the problem.

905
00:44:09,580 --> 00:44:14,640
And the goal was
to solve-- to find

906
00:44:14,640 --> 00:44:17,884
paths that minimize
the product of weights.

907
00:44:17,884 --> 00:44:19,300
But what we've
covered in class is

908
00:44:19,300 --> 00:44:21,910
how to solve a problem when
it's the sum of weights.

909
00:44:21,910 --> 00:44:23,890
How do you do it?

910
00:44:23,890 --> 00:44:26,070
In one word, or less?

911
00:44:26,070 --> 00:44:26,990
Logs.

912
00:44:26,990 --> 00:44:28,920
Just take logs.

913
00:44:28,920 --> 00:44:31,597
That converts
products into sums.

914
00:44:31,597 --> 00:44:32,930
Now you start to get the flavor.

915
00:44:32,930 --> 00:44:37,150
This is a problem that you could
take Djikstra or Bellman-Ford,

916
00:44:37,150 --> 00:44:39,390
and change all the
relaxation steps

917
00:44:39,390 --> 00:44:42,470
and change it to work
directly with products.

918
00:44:42,470 --> 00:44:46,570
That would work,
but it's more work.

919
00:44:46,570 --> 00:44:49,200
You have to prove that
that's still correct.

920
00:44:49,200 --> 00:44:50,500
It's annoying to think about.

921
00:44:50,500 --> 00:44:52,660
And it's annoying to program.

922
00:44:52,660 --> 00:44:54,590
It's not modular,
blah, blah, blah.

923
00:44:54,590 --> 00:44:56,720
Whereas if you just
do this reduction,

924
00:44:56,720 --> 00:44:59,990
you can use exactly the
code that you had before,

925
00:44:59,990 --> 00:45:01,960
at the end.

926
00:45:01,960 --> 00:45:03,220
So that's nice.

927
00:45:03,220 --> 00:45:04,670
This is why
reductions are really

928
00:45:04,670 --> 00:45:07,562
the most common algorithm design
technique because you don't

929
00:45:07,562 --> 00:45:10,020
want to implement an algorithm
for every single problem you

930
00:45:10,020 --> 00:45:10,700
have.

931
00:45:10,700 --> 00:45:13,200
It would be nice if you could
reuse some of those algorithms

932
00:45:13,200 --> 00:45:14,630
that you had before.

933
00:45:14,630 --> 00:45:17,100
Reductions let you do that.

934
00:45:17,100 --> 00:45:21,680
Another one, which was on the
quiz in the true-false-- quiz

935
00:45:21,680 --> 00:45:25,532
two-- was converting longest
path into shortest path.

936
00:45:25,532 --> 00:45:26,990
We didn't phrase
it as a reduction.

937
00:45:26,990 --> 00:45:29,730
It was just can you
solve longest path using

938
00:45:29,730 --> 00:45:30,910
Bellman-Ford.

939
00:45:30,910 --> 00:45:31,832
And the answer is yes.

940
00:45:31,832 --> 00:45:33,165
You just negate all the weights.

941
00:45:33,165 --> 00:45:34,900
And that converts a
longest path problem

942
00:45:34,900 --> 00:45:37,660
into a shortest path problem.

943
00:45:37,660 --> 00:45:40,310
Easy.

944
00:45:40,310 --> 00:45:43,030
Also on the quiz-- maybe I don't
need to write all of these down

945
00:45:43,030 --> 00:45:45,200
because they're a little
bit weird problems.

946
00:45:45,200 --> 00:45:46,370
We made them up.

947
00:45:46,370 --> 00:45:50,220
There was the-- what was
the duck tour called?

948
00:45:50,220 --> 00:45:50,990
Bird tours?

949
00:45:50,990 --> 00:45:51,950
Bird tours?

950
00:45:51,950 --> 00:45:52,700
Aviation tours?

951
00:45:52,700 --> 00:45:53,610
Whatever.

952
00:45:53,610 --> 00:45:56,990
You want to visit a bunch of
sites in some specified order.

953
00:45:56,990 --> 00:45:58,990
The point in that problem
is you could reduce it

954
00:45:58,990 --> 00:46:02,900
to a single shortest
paths query.

955
00:46:02,900 --> 00:46:05,682
And so if you already
have shortest path code,

956
00:46:05,682 --> 00:46:06,890
you don't have to think much.

957
00:46:06,890 --> 00:46:08,400
You just do the
graph application.

958
00:46:08,400 --> 00:46:09,970
Done.

959
00:46:09,970 --> 00:46:11,600
Then there's the
leaky tank problem,

960
00:46:11,600 --> 00:46:14,570
which is also a graph
reduction problem.

961
00:46:14,570 --> 00:46:16,570
You could represent all
these extra weird things

962
00:46:16,570 --> 00:46:18,640
that were happening
in your car by just

963
00:46:18,640 --> 00:46:20,202
changing the graph a little bit.

964
00:46:20,202 --> 00:46:21,660
And it's a very
powerful technique.

965
00:46:21,660 --> 00:46:24,860
In this class, we see it
mostly in graph reductions.

966
00:46:24,860 --> 00:46:28,120
But it could apply
all over the place.

967
00:46:28,120 --> 00:46:30,810
And while this is a powerful
technique for coming up

968
00:46:30,810 --> 00:46:34,310
with new algorithms, it's
also a powerful technique

969
00:46:34,310 --> 00:46:41,380
for proving things
like Tetris is NP-hard.

970
00:46:41,380 --> 00:46:43,830
So what we proved
is that a problem

971
00:46:43,830 --> 00:46:49,600
called 3-Partition can
be reduced to Tetris.

972
00:46:49,600 --> 00:46:57,810

973
00:46:57,810 --> 00:46:58,610
What's 3-Partition?

974
00:46:58,610 --> 00:47:01,000
3-Partition is I
give you n numbers.

975
00:47:01,000 --> 00:47:03,930
I want to know can I
divide them into triples,

976
00:47:03,930 --> 00:47:06,450
each of the same sum.

977
00:47:06,450 --> 00:47:07,780
So I have n numbers.

978
00:47:07,780 --> 00:47:10,170
Divide them into n
over 3 groups of 3,

979
00:47:10,170 --> 00:47:14,030
such that the sum of
each of the 3s is equal.

980
00:47:14,030 --> 00:47:15,780
Sounds like an easy
enough problem.

981
00:47:15,780 --> 00:47:18,230
But it's an NP-complete problem.

982
00:47:18,230 --> 00:47:22,950
And people knew that since
one of the first papers.

983
00:47:22,950 --> 00:47:26,790
I guess that was late
'70s, early '80s, by Karp.

984
00:47:26,790 --> 00:47:28,800
So Karp already proved
this is standing

985
00:47:28,800 --> 00:47:32,410
on the shoulders of giants.

986
00:47:32,410 --> 00:47:34,360
Karp proved 3-Partition
is NP-complete,

987
00:47:34,360 --> 00:47:37,060
so I don't need to
think about that.

988
00:47:37,060 --> 00:47:39,210
All I need to
focus on is showing

989
00:47:39,210 --> 00:47:43,470
that Tetris is harder
than 3-Partition.

990
00:47:43,470 --> 00:47:45,270
This is what I mean by harder.

991
00:47:45,270 --> 00:47:48,990
Harder means-- so when
I can reduce A to B,

992
00:47:48,990 --> 00:48:02,090
we say the A-- B is at least
as hard as A. Why's that?

993
00:48:02,090 --> 00:48:05,820
Because I can solve A by solving
B. I just apply this reduction

994
00:48:05,820 --> 00:48:08,570
and then solve B. So if I
had some good way to solve B,

995
00:48:08,570 --> 00:48:11,110
it would turn into a
good way to solve A.

996
00:48:11,110 --> 00:48:14,940
Now 3-Partition-- which
is A, here-- we're

997
00:48:14,940 --> 00:48:17,440
pretty sure there's no good
algorithm for solving this.

998
00:48:17,440 --> 00:48:22,900
Pretty sure it's not in P.
And so Tetris better not be P

999
00:48:22,900 --> 00:48:25,430
either because if
Tetris were in P, then

1000
00:48:25,430 --> 00:48:27,140
we could just take
our 3-Partition,

1001
00:48:27,140 --> 00:48:30,990
reduce it to Tetris, and then
3-Partition would be in P.

1002
00:48:30,990 --> 00:48:33,210
In fact, all of the
NP-complete problems,

1003
00:48:33,210 --> 00:48:36,470
you can reduce to each other.

1004
00:48:36,470 --> 00:48:39,820
And so to show that something
is at that little position,

1005
00:48:39,820 --> 00:48:41,900
NP-complete, all
you need to do is

1006
00:48:41,900 --> 00:48:44,120
find some known
NP-complete problem

1007
00:48:44,120 --> 00:48:47,520
and reduce it to your problem.

1008
00:48:47,520 --> 00:48:51,400
So reductions are super useful
for getting positive results

1009
00:48:51,400 --> 00:48:53,580
for making new
algorithms, but also

1010
00:48:53,580 --> 00:48:56,110
for proving negative results--
showing that one problem is

1011
00:48:56,110 --> 00:48:57,310
harder than another.

1012
00:48:57,310 --> 00:48:59,080
And if you already
believe this is hard,

1013
00:48:59,080 --> 00:49:00,621
then you should
believe this is hard.

1014
00:49:00,621 --> 00:49:08,570

1015
00:49:08,570 --> 00:49:12,060
I think that's all I
really have time for.

1016
00:49:12,060 --> 00:49:14,480
I'll give you a couple
more NP-complete problems.

1017
00:49:14,480 --> 00:49:15,930
Kind of fun.

1018
00:49:15,930 --> 00:49:18,896
Traveling salesman problem,
you may have heard of.

1019
00:49:18,896 --> 00:49:20,020
Let's say you have a graph.

1020
00:49:20,020 --> 00:49:22,040
And you want to find out
the shortest path that

1021
00:49:22,040 --> 00:49:25,770
visits all the vertices,
not just one vertex.

1022
00:49:25,770 --> 00:49:28,680
That's NP-complete.

1023
00:49:28,680 --> 00:49:31,680
We solved longest common
subsequence for two strings,

1024
00:49:31,680 --> 00:49:33,280
but if I give you
n strings that you

1025
00:49:33,280 --> 00:49:35,238
need to find the longest
common subsequence of,

1026
00:49:35,238 --> 00:49:37,730
that's NP-complete.

1027
00:49:37,730 --> 00:49:41,560
Minesweeper, Sudoku, most
puzzles that are interesting

1028
00:49:41,560 --> 00:49:43,990
are NP-complete.

1029
00:49:43,990 --> 00:49:45,360
SAT.

1030
00:49:45,360 --> 00:49:53,120
SAT is a-- I give you a Boolean
formula like x or y AND NOT

1031
00:49:53,120 --> 00:49:55,050
x-- something like that.

1032
00:49:55,050 --> 00:49:57,499
I want to know is there some
setting of the variables that

1033
00:49:57,499 --> 00:49:58,790
makes this thing come out true?

1034
00:49:58,790 --> 00:50:01,634
Is it possible to
make this true?

1035
00:50:01,634 --> 00:50:02,800
That's NP-complete complete.

1036
00:50:02,800 --> 00:50:04,310
This was actually
the first problem

1037
00:50:04,310 --> 00:50:05,610
that was shown NP-complete.

1038
00:50:05,610 --> 00:50:06,880
There's this issue, right?

1039
00:50:06,880 --> 00:50:08,754
If I'm going to show
everything's NP-complete

1040
00:50:08,754 --> 00:50:10,910
by reduction, how the
heck do I get started?

1041
00:50:10,910 --> 00:50:12,360
What's the first problem?

1042
00:50:12,360 --> 00:50:15,620
And this is the first problem.

1043
00:50:15,620 --> 00:50:18,580
You could sort of prove it
by definition, almost, of NP,

1044
00:50:18,580 --> 00:50:19,480
here.

1045
00:50:19,480 --> 00:50:22,760
But I won't do that.

1046
00:50:22,760 --> 00:50:24,610
Three coloring a graph.

1047
00:50:24,610 --> 00:50:25,280
Shortest paths.

1048
00:50:25,280 --> 00:50:26,010
This is fun.

1049
00:50:26,010 --> 00:50:27,840
Shortest paths in
a graph is hard.

1050
00:50:27,840 --> 00:50:30,620
But in the real world, we
live in a three dimensional,

1051
00:50:30,620 --> 00:50:31,880
geometric environment.

1052
00:50:31,880 --> 00:50:33,338
What if I want to
find the shortest

1053
00:50:33,338 --> 00:50:35,620
path from this point,
where I am, to that point,

1054
00:50:35,620 --> 00:50:37,500
over on the ceiling
or something.

1055
00:50:37,500 --> 00:50:40,020
And I can fly.

1056
00:50:40,020 --> 00:50:41,669
That's NP-complete.

1057
00:50:41,669 --> 00:50:42,460
It's kind of weird.

1058
00:50:42,460 --> 00:50:44,160
Shortest paths in a two
dimensional environment

1059
00:50:44,160 --> 00:50:44,743
is polynomial.

1060
00:50:44,743 --> 00:50:47,532
It's a good thing that we are
on ground because, then, we

1061
00:50:47,532 --> 00:50:48,990
can model things
by two dimensions.

1062
00:50:48,990 --> 00:50:50,470
We can model things by graphs.

1063
00:50:50,470 --> 00:50:53,500
But in 3D, shortest
paths is NP-complete.

1064
00:50:53,500 --> 00:50:56,139
So all these things where
a problem-- knapsack,

1065
00:50:56,139 --> 00:50:56,930
that's another one.

1066
00:50:56,930 --> 00:50:58,221
We've already covered knapsack.

1067
00:50:58,221 --> 00:50:59,990
We saw a pseudo-polynomial
algorithm.

1068
00:50:59,990 --> 00:51:02,390
Turns out, you can't do
better than pseudo-polynomial

1069
00:51:02,390 --> 00:51:07,030
unless P equals NP because
knapsack is NP-complete.

1070
00:51:07,030 --> 00:51:08,160
So there you go.

1071
00:51:08,160 --> 00:51:11,313
Computational complexity
in 50 minutes.

1072
00:51:11,313 --> 00:51:11,813