1
00:00:00,000 --> 00:00:00,080

2
00:00:00,080 --> 00:00:01,800
The following
content is provided

3
00:00:01,800 --> 00:00:04,040
under a Creative
Commons license.

4
00:00:04,040 --> 00:00:06,880
Your support will help MIT
OpenCourseWare continue

5
00:00:06,880 --> 00:00:10,740
to offer high quality
educational resources for free.

6
00:00:10,740 --> 00:00:13,350
To make a donation, or
view additional materials

7
00:00:13,350 --> 00:00:17,237
from hundreds of MIT courses,
visit MIT OpenCourseWare

8
00:00:17,237 --> 00:00:17,862
at ocw.mit.edu.

9
00:00:17,862 --> 00:00:22,460

10
00:00:22,460 --> 00:00:24,510
PROFESSOR: Good
morning, everyone.

11
00:00:24,510 --> 00:00:26,740
Let's get started
on lecture number

12
00:00:26,740 --> 00:00:30,580
two of four lecture
sequences of shortest paths.

13
00:00:30,580 --> 00:00:34,220
So, last time, we talked
about a general structure

14
00:00:34,220 --> 00:00:37,160
for a shortest path algorithm.

15
00:00:37,160 --> 00:00:40,022
Today, we'll actually look
at a concrete algorithm

16
00:00:40,022 --> 00:00:40,980
that's due to Dijkstra.

17
00:00:40,980 --> 00:00:43,990

18
00:00:43,990 --> 00:00:45,960
Before we get to
that, I want to do

19
00:00:45,960 --> 00:00:49,610
a little bit of a
review of the concepts

20
00:00:49,610 --> 00:00:54,450
that we covered in
the lecture last week.

21
00:00:54,450 --> 00:00:56,590
In particular, we
talked about this notion

22
00:00:56,590 --> 00:00:59,425
of relaxation, which is
a fundamental operation

23
00:00:59,425 --> 00:01:01,630
in all shortest path algorithms.

24
00:01:01,630 --> 00:01:03,680
And I want to go
over that again.

25
00:01:03,680 --> 00:01:06,020
We look at a couple
of special cases

26
00:01:06,020 --> 00:01:10,080
today, with respect to
algorithms for shortest paths.

27
00:01:10,080 --> 00:01:13,440
We look at a Directed
Acyclic Graph.

28
00:01:13,440 --> 00:01:17,430
Then your graph has
no cycles in it.

29
00:01:17,430 --> 00:01:22,770
Regardless of whether you
have negative edges or not,

30
00:01:22,770 --> 00:01:24,440
there's a
straightforward algorithm

31
00:01:24,440 --> 00:01:28,760
that we look at to find
shortest paths and DAGs.

32
00:01:28,760 --> 00:01:30,770
And then, we'll
focus in on the case

33
00:01:30,770 --> 00:01:32,660
where there are
no negative edges.

34
00:01:32,660 --> 00:01:35,970
And talk about
Dijkstra's algorithm.

35
00:01:35,970 --> 00:01:43,190
So, to start with
the review, here's,

36
00:01:43,190 --> 00:01:46,330
really, a trivial
example of a graph

37
00:01:46,330 --> 00:01:50,000
that we want to compute
the shortest paths on.

38
00:01:50,000 --> 00:01:56,780
And the numbers that are
inside these vertices

39
00:01:56,780 --> 00:01:58,320
are our priority values.

40
00:01:58,320 --> 00:02:09,720
So, think of d of v as the
length of the current shortest

41
00:02:09,720 --> 00:02:16,250
path from the source, s, to v.

42
00:02:16,250 --> 00:02:22,900
And, given the source, s, the
length to the source is 0.

43
00:02:22,900 --> 00:02:24,130
So d of s is 0.

44
00:02:24,130 --> 00:02:26,590
It starts at 0 and ends at 0.

45
00:02:26,590 --> 00:02:29,940
And other ones, I
initialized to infinity.

46
00:02:29,940 --> 00:02:35,180
And through this process
that we call relaxation,

47
00:02:35,180 --> 00:02:40,770
we can generally
reduce these d values,

48
00:02:40,770 --> 00:02:42,930
that are the lengths of
the current shortest paths,

49
00:02:42,930 --> 00:02:47,025
down to what we call
the delta values.

50
00:02:47,025 --> 00:02:49,610

51
00:02:49,610 --> 00:02:53,790
Which is the length
of our shortest path.

52
00:02:53,790 --> 00:02:57,030

53
00:02:57,030 --> 00:02:57,945
It may be unique.

54
00:02:57,945 --> 00:02:59,750
It may not be unique.

55
00:02:59,750 --> 00:03:02,280
But you have to get
the minimum value.

56
00:03:02,280 --> 00:03:09,330
And then, all of the vertices
have convergent values

57
00:03:09,330 --> 00:03:11,710
of d that converge to delta.

58
00:03:11,710 --> 00:03:14,120
Then, your algorithm is done.

59
00:03:14,120 --> 00:03:19,490
And one last thing that is
important to reconstruct

60
00:03:19,490 --> 00:03:26,900
the path is the notion
of a predecessor and pi v

61
00:03:26,900 --> 00:03:36,530
is the predecessor of v in
the shortest path from s

62
00:03:36,530 --> 00:03:44,180
to v. And you can
follow this predecessor

63
00:03:44,180 --> 00:03:46,810
chain to reconstruct
the shortest path,

64
00:03:46,810 --> 00:03:51,560
once you've converged,
and all of the values

65
00:03:51,560 --> 00:03:57,140
are down to the delta s comma
v. So, in this trivial example,

66
00:03:57,140 --> 00:04:04,580
you start with d of s being 0, d
of a and d of b being infinity.

67
00:04:04,580 --> 00:04:10,560
Let's put on it a
few weights here.

68
00:04:10,560 --> 00:04:13,520
And what you do is
potentially relax

69
00:04:13,520 --> 00:04:16,510
the edges that go out of s.

70
00:04:16,510 --> 00:04:19,489
And this notion of relaxation,
that I'll write out formally

71
00:04:19,489 --> 00:04:21,940
in a minute-- we
looked at it last time,

72
00:04:21,940 --> 00:04:24,180
is a process of
following this edge,

73
00:04:24,180 --> 00:04:26,710
and updating the d of a value.

74
00:04:26,710 --> 00:04:30,140
And this infinity becomes
1 because you say, well,

75
00:04:30,140 --> 00:04:33,590
if I start here with 0 and
I add 1 to it, I get 1 here.

76
00:04:33,590 --> 00:04:35,830
Similarly, this
infinity becomes 3.

77
00:04:35,830 --> 00:04:38,100
And, at this point,
you've relaxed the edges

78
00:04:38,100 --> 00:04:43,040
that go out of s two these
other two nodes, a and b.

79
00:04:43,040 --> 00:04:45,532
You're not quite done yet.

80
00:04:45,532 --> 00:04:49,770
At this point, you could imagine
that, at least in this example,

81
00:04:49,770 --> 00:04:52,350
you found the shortest
path to the vertex a.

82
00:04:52,350 --> 00:04:57,940
But it is, in fact, a path
of length, 2, to vertex b.

83
00:04:57,940 --> 00:05:01,540
Right now, we think that the
the current shortest path to b,

84
00:05:01,540 --> 00:05:05,500
after the first step of
relaxing the edges from s,

85
00:05:05,500 --> 00:05:06,720
happens to be 3.

86
00:05:06,720 --> 00:05:13,360
But if you go like so,
then you end up with the 2.

87
00:05:13,360 --> 00:05:15,790
And, at this point, you're done.

88
00:05:15,790 --> 00:05:20,380
Now we have to prove that any
particular algorithm we put up

89
00:05:20,380 --> 00:05:24,760
is going to converge to the
delta values, and the algorithm

90
00:05:24,760 --> 00:05:25,374
to terminate.

91
00:05:25,374 --> 00:05:27,790
And then, we have to worry
about the asymptotic complexity

92
00:05:27,790 --> 00:05:28,930
of the algorithm.

93
00:05:28,930 --> 00:05:31,060
But that's the
general overall flow.

94
00:05:31,060 --> 00:05:34,060
And we look at, as I said,
two algorithms today.

95
00:05:34,060 --> 00:05:35,520
Both special cases.

96
00:05:35,520 --> 00:05:38,380
One for DAGs and one
for non-negative edges.

97
00:05:38,380 --> 00:05:41,430
And we'll go through, and
maybe not do a formal proof,

98
00:05:41,430 --> 00:05:44,320
but suddenly give you
a strong intuition

99
00:05:44,320 --> 00:05:46,990
as to why these algorithms work.

100
00:05:46,990 --> 00:05:52,750
Any questions about
this material?

101
00:05:52,750 --> 00:05:54,920
OK.

102
00:05:54,920 --> 00:05:58,220
So, what I want
to do is give you

103
00:05:58,220 --> 00:06:04,770
a sense for why this
relaxation step is useful.

104
00:06:04,770 --> 00:06:08,470
But also, importantly,
safe, or correct.

105
00:06:08,470 --> 00:06:15,220
And recall that our basic
relaxation operation, which

106
00:06:15,220 --> 00:06:19,740
we did over here, as we
updated the infinity value to 1

107
00:06:19,740 --> 00:06:24,100
and the 3 value to 2, et
cetera, looks like this.

108
00:06:24,100 --> 00:06:33,510
It says, if d of v is greater
than d of u plus w u,v. Then,

109
00:06:33,510 --> 00:06:40,100
I'm going to update d of v
to be d of u plus w u, v.

110
00:06:40,100 --> 00:06:44,070
You found a better way
of reaching vertex v.

111
00:06:44,070 --> 00:06:44,895
A shorter way.

112
00:06:44,895 --> 00:06:48,560

113
00:06:48,560 --> 00:06:51,920
And this way happens to be
going through the vertex, u.

114
00:06:51,920 --> 00:06:55,330
So you update not only the
priority value, but also

115
00:06:55,330 --> 00:06:57,450
the predecessor relationship.

116
00:06:57,450 --> 00:06:57,950
All right?

117
00:06:57,950 --> 00:06:59,940
That's the relaxation step.

118
00:06:59,940 --> 00:07:04,805
Now, I want to be able to
show that relaxation is safe.

119
00:07:04,805 --> 00:07:10,200

120
00:07:10,200 --> 00:07:11,760
What do I mean by that?

121
00:07:11,760 --> 00:07:16,470
Well, I want to make sure
that I never relax an edge

122
00:07:16,470 --> 00:07:18,490
and somehow do
something wrong, which

123
00:07:18,490 --> 00:07:23,320
gets me a value that's
less than delta s v.

124
00:07:23,320 --> 00:07:25,880
I want to be able to
converge from the top.

125
00:07:25,880 --> 00:07:28,840
I want to be able to start
with these infinity values

126
00:07:28,840 --> 00:07:31,660
because I don't have a path
to this particular vertex,

127
00:07:31,660 --> 00:07:35,700
and continually reduce the
values of the priorities.

128
00:07:35,700 --> 00:07:39,459
And then get down to delta, the
correct values, and don't go,

129
00:07:39,459 --> 00:07:40,750
I don't want to go any further.

130
00:07:40,750 --> 00:07:41,470
All right?

131
00:07:41,470 --> 00:07:44,130
Because, if I get below,
then you're talking about,

132
00:07:44,130 --> 00:07:46,170
essentially, you may
be able to get back up,

133
00:07:46,170 --> 00:07:49,630
but that is not the kind
of algorithm that we want.

134
00:07:49,630 --> 00:07:51,960
At least, algorithms
we look at here.

135
00:07:51,960 --> 00:07:53,930
And that is dangerous.

136
00:07:53,930 --> 00:07:56,850
So we want relaxation
to be safe.

137
00:07:56,850 --> 00:08:02,510
And we can fairly easily
prove a simple lemma,

138
00:08:02,510 --> 00:08:10,280
using induction, that
says that the relaxation

139
00:08:10,280 --> 00:08:13,690
operation-- and
it doesn't matter

140
00:08:13,690 --> 00:08:15,690
what sequence you relax things.

141
00:08:15,690 --> 00:08:17,595
This is a fairly
powerful lemma that

142
00:08:17,595 --> 00:08:20,850
says that if you have an
algorithm that uses relaxation,

143
00:08:20,850 --> 00:08:25,850
and that's the only way of
updating these d values,

144
00:08:25,850 --> 00:08:27,560
then it's safe.

145
00:08:27,560 --> 00:08:30,934
You're not going to get a
wrong, shortest path value.

146
00:08:30,934 --> 00:08:32,350
Either at the end
of the algorithm

147
00:08:32,350 --> 00:08:35,299
or at any time during the
running, or the execution,

148
00:08:35,299 --> 00:08:36,410
of this algorithm.

149
00:08:36,410 --> 00:08:36,909
OK?

150
00:08:36,909 --> 00:08:39,890
So the relaxation
operation algorithm

151
00:08:39,890 --> 00:08:53,160
maintains the
invariant that d of v

152
00:08:53,160 --> 00:09:02,310
is greater than or equal to
delta s, v for all vertices.

153
00:09:02,310 --> 00:09:03,230
OK?

154
00:09:03,230 --> 00:09:05,376
So that's a powerful lemma.

155
00:09:05,376 --> 00:09:07,250
It's a fairly straightforward
lemma to prove.

156
00:09:07,250 --> 00:09:09,750
But it's an important lemma.

157
00:09:09,750 --> 00:09:13,330
It tells us that we can
create the generic structure

158
00:09:13,330 --> 00:09:16,480
of the shortest path algorithm
that I talked about last week.

159
00:09:16,480 --> 00:09:19,370
It says, pick an edge.

160
00:09:19,370 --> 00:09:20,311
Relax it.

161
00:09:20,311 --> 00:09:21,060
Pick another edge.

162
00:09:21,060 --> 00:09:21,997
Relax it.

163
00:09:21,997 --> 00:09:23,580
And hopefully
everything will work out

164
00:09:23,580 --> 00:09:25,480
and you'll get
your delta values.

165
00:09:25,480 --> 00:09:28,927
And what this lemma
says is, you'll

166
00:09:28,927 --> 00:09:30,510
never get something
in the middle that

167
00:09:30,510 --> 00:09:32,500
is less than your
shortest path value.

168
00:09:32,500 --> 00:09:35,780
And if you keep running
over for long enough time,

169
00:09:35,780 --> 00:09:37,440
depending on the
particular heuristic

170
00:09:37,440 --> 00:09:39,560
that you use for
selecting the edges,

171
00:09:39,560 --> 00:09:41,570
your algorithm will
eventually terminate.

172
00:09:41,570 --> 00:09:46,740
And, hopefully, it'll
run in polynomial time.

173
00:09:46,740 --> 00:09:50,500
So, how do we prove this?

174
00:09:50,500 --> 00:09:52,620
I'm going to do
about half of it,

175
00:09:52,620 --> 00:09:56,160
then try and get
you to finish it.

176
00:09:56,160 --> 00:10:04,640
So it's by induction
on the number of steps,

177
00:10:04,640 --> 00:10:14,920
in the sense that we are going
to essentially assume that d

178
00:10:14,920 --> 00:10:23,950
of u is greater than
or equal to delta s,u.

179
00:10:23,950 --> 00:10:28,850
And we're going to do
this relaxation operation.

180
00:10:28,850 --> 00:10:33,235
So it's like a base case
is that this is correct.

181
00:10:33,235 --> 00:10:36,680

182
00:10:36,680 --> 00:10:43,450
And now we want to show that
the relaxation operation doesn't

183
00:10:43,450 --> 00:10:47,090
make d of v incorrect.

184
00:10:47,090 --> 00:10:52,025
So, that's the
inductive hypothesis.

185
00:10:52,025 --> 00:10:54,660

186
00:10:54,660 --> 00:11:00,680
Now, we can say by the
triangle inequality

187
00:11:00,680 --> 00:11:05,590
that I talked about late
in last week's lecture,

188
00:11:05,590 --> 00:11:12,050
you have delta s, v less than
or equal to delta s comma

189
00:11:12,050 --> 00:11:17,660
u plus delta u comma
v. And what is that?

190
00:11:17,660 --> 00:11:26,670
Well, that just says, if I
have something like this,

191
00:11:26,670 --> 00:11:30,340
that I have s.

192
00:11:30,340 --> 00:11:35,570
Let's call this u and v.

193
00:11:35,570 --> 00:11:38,970
This is not an edge between
s and v. It's a path.

194
00:11:38,970 --> 00:11:40,340
It could be a single edge.

195
00:11:40,340 --> 00:11:42,600
But we think of this
as a path between s

196
00:11:42,600 --> 00:11:47,030
and v. This is a
path between s and u.

197
00:11:47,030 --> 00:11:50,890
This is a path between u and v.

198
00:11:50,890 --> 00:11:57,780
And, in particular,
if there's a way

199
00:11:57,780 --> 00:12:08,640
of getting from s to u and u
to v that happens to be shorter

200
00:12:08,640 --> 00:12:12,980
then the best way of
getting from s to v,

201
00:12:12,980 --> 00:12:14,831
well, that's a contradiction.

202
00:12:14,831 --> 00:12:15,330
OK?

203
00:12:15,330 --> 00:12:21,270
Because this is the shortest
way of getting from s to v.

204
00:12:21,270 --> 00:12:23,600
And it has no constraints
over the number of edges

205
00:12:23,600 --> 00:12:26,750
that it incorporates.

206
00:12:26,750 --> 00:12:28,730
And so, by definition,
the shortest way

207
00:12:28,730 --> 00:12:31,140
of getting from s to v is
either some direct way.

208
00:12:31,140 --> 00:12:32,460
Maybe there's a single edge.

209
00:12:32,460 --> 00:12:36,611
Or it may go through
this vertex, u.

210
00:12:36,611 --> 00:12:37,110
All right?

211
00:12:37,110 --> 00:12:39,890
So that's the
triangle inequality.

212
00:12:39,890 --> 00:12:44,160
Notice that, what I
have here, is something

213
00:12:44,160 --> 00:12:50,670
where going from s,
to a, to b is actually

214
00:12:50,670 --> 00:12:53,062
shorter than going from s to b.

215
00:12:53,062 --> 00:12:55,020
But these are single
edges we're talking about.

216
00:12:55,020 --> 00:12:56,220
These are weights
we're talking about.

217
00:12:56,220 --> 00:12:57,880
And there's no
contradiction here

218
00:12:57,880 --> 00:13:01,930
because all this says is
that, what I want to see here

219
00:13:01,930 --> 00:13:07,470
is delta s comma b
is going to be 2.

220
00:13:07,470 --> 00:13:08,840
OK?

221
00:13:08,840 --> 00:13:11,310
Initially, I may be starting
out with infinity and 3

222
00:13:11,310 --> 00:13:12,900
for the d values.

223
00:13:12,900 --> 00:13:15,160
But the delta value,
which is the shortest way

224
00:13:15,160 --> 00:13:17,510
of getting to b,
happens to go through a.

225
00:13:17,510 --> 00:13:20,150
And so, if you use that,
then the triangle inequality

226
00:13:20,150 --> 00:13:21,060
makes sense.

227
00:13:21,060 --> 00:13:23,940
So don't get confused
when you see pictures

228
00:13:23,940 --> 00:13:29,020
like this, where the weights
don't obey the triangle

229
00:13:29,020 --> 00:13:30,040
inequality.

230
00:13:30,040 --> 00:13:33,680
The triangle inequality has to
do with the shortest paths, not

231
00:13:33,680 --> 00:13:35,101
the single edge ways.

232
00:13:35,101 --> 00:13:35,600
OK?

233
00:13:35,600 --> 00:13:38,410

234
00:13:38,410 --> 00:13:42,320
So, that's half the proof here.

235
00:13:42,320 --> 00:13:46,790
What I've done is assumed
that d of u is correct.

236
00:13:46,790 --> 00:13:50,060
And I've used the
triangle inequality.

237
00:13:50,060 --> 00:13:51,680
And I've just written this down.

238
00:13:51,680 --> 00:13:58,200
Now, someone do the last step,
or the second to last step,

239
00:13:58,200 --> 00:13:59,730
of this proof.

240
00:13:59,730 --> 00:14:00,230
Anybody?

241
00:14:00,230 --> 00:14:03,100

242
00:14:03,100 --> 00:14:05,800
What can I say now, given
that what I have here.

243
00:14:05,800 --> 00:14:09,080
Look at these two values.

244
00:14:09,080 --> 00:14:12,620
What can I say
about these values?

245
00:14:12,620 --> 00:14:14,520
How can I prove what
I want to prove,

246
00:14:14,520 --> 00:14:19,750
which is, basically, delta of
s comma v should be less than

247
00:14:19,750 --> 00:14:21,560
or equal to d of v?

248
00:14:21,560 --> 00:14:22,190
OK.

249
00:14:22,190 --> 00:14:24,680
That's what I want to show.

250
00:14:24,680 --> 00:14:26,780
I've just written
another way here.

251
00:14:26,780 --> 00:14:27,510
How do I do that?

252
00:14:27,510 --> 00:14:30,946

253
00:14:30,946 --> 00:14:31,446
Anyone?

254
00:14:31,446 --> 00:14:36,380

255
00:14:36,380 --> 00:14:45,810
What can I substitute for--
there's a less than operator,

256
00:14:45,810 --> 00:14:48,830
which means that I can
replace things over here.

257
00:14:48,830 --> 00:14:49,635
Yeah.

258
00:14:49,635 --> 00:14:53,017
AUDIENCE: If you, like,
you have a [INAUDIBLE]?

259
00:14:53,017 --> 00:14:53,600
PROFESSOR: Ah.

260
00:14:53,600 --> 00:14:54,100
Excellent.

261
00:14:54,100 --> 00:14:59,260
So the first thing is, I could
put d of u over here, right?

262
00:14:59,260 --> 00:15:04,150
Less than or equal to d of u.

263
00:15:04,150 --> 00:15:06,770
And the reason I can do
that is because d of u

264
00:15:06,770 --> 00:15:09,540
is greater then delta s comma u.

265
00:15:09,540 --> 00:15:13,070
So that's cool, right?

266
00:15:13,070 --> 00:15:13,690
Sorry, delta.

267
00:15:13,690 --> 00:15:14,680
Thank you.

268
00:15:14,680 --> 00:15:15,900
Delta s comma u.

269
00:15:15,900 --> 00:15:16,960
Thank you.

270
00:15:16,960 --> 00:15:18,630
And so, that's what I got here.

271
00:15:18,630 --> 00:15:20,040
What else?

272
00:15:20,040 --> 00:15:20,540
Yeah?

273
00:15:20,540 --> 00:15:24,074
AUDIENCE: You replace
delta u, v with w u, v.

274
00:15:24,074 --> 00:15:25,990
PROFESSOR: I can replace
delta u, v with w, u,

275
00:15:25,990 --> 00:15:28,710
v. Exactly right.

276
00:15:28,710 --> 00:15:29,720
Exactly right.

277
00:15:29,720 --> 00:15:30,320
Great.

278
00:15:30,320 --> 00:15:31,560
That deserves a cushion.

279
00:15:31,560 --> 00:15:33,420
I think you already have one.

280
00:15:33,420 --> 00:15:35,041
Yep.

281
00:15:35,041 --> 00:15:35,540
Oh, man.

282
00:15:35,540 --> 00:15:39,030
I should have not-- so you
get that because I messed up.

283
00:15:39,030 --> 00:15:40,930
Seems like you
need to get-- whoa.

284
00:15:40,930 --> 00:15:41,510
Hey.

285
00:15:41,510 --> 00:15:42,520
OK.

286
00:15:42,520 --> 00:15:44,270
You get one because I
hit you on the head.

287
00:15:44,270 --> 00:15:45,190
All right.

288
00:15:45,190 --> 00:15:46,440
And this time, I'll just save.

289
00:15:46,440 --> 00:15:47,814
I'm running out
of cushions here.

290
00:15:47,814 --> 00:15:51,890
But I've got some in my office.

291
00:15:51,890 --> 00:15:52,710
All right.

292
00:15:52,710 --> 00:15:53,270
So that's it.

293
00:15:53,270 --> 00:15:54,860
That's the proof.

294
00:15:54,860 --> 00:15:56,032
OK?

295
00:15:56,032 --> 00:15:56,990
Fairly straightforward.

296
00:15:56,990 --> 00:15:59,860

297
00:15:59,860 --> 00:16:04,290
You get to the
point where you want

298
00:16:04,290 --> 00:16:07,000
to apply the
triangle inequality.

299
00:16:07,000 --> 00:16:12,990
You simply look at each of
these terms and, by induction

300
00:16:12,990 --> 00:16:16,350
hypothesis, you
could put d,u here.

301
00:16:16,350 --> 00:16:18,500
And, I just talked
about the weights,

302
00:16:18,500 --> 00:16:20,480
and so on, and so forth.

303
00:16:20,480 --> 00:16:23,630
And you know that w u,v,
which is a direct way,

304
00:16:23,630 --> 00:16:29,640
a single edge way,
of getting to a node,

305
00:16:29,640 --> 00:16:33,550
has to be greater than
the shortest path.

306
00:16:33,550 --> 00:16:36,290
Like here, this 3
value is a direct way

307
00:16:36,290 --> 00:16:38,520
of getting from s to b.

308
00:16:38,520 --> 00:16:41,210
And, in this case, it's
greater than the shortest

309
00:16:41,210 --> 00:16:42,770
path, which is of length 2.

310
00:16:42,770 --> 00:16:45,710
But it can never be smaller
than the shortest path.

311
00:16:45,710 --> 00:16:51,250
And so, once we have that
here, we can essentially say,

312
00:16:51,250 --> 00:16:55,010
we know that delta s, v is less
than or equal to d u plus d v.

313
00:16:55,010 --> 00:16:57,530
Which implies, of course,
that this is simply--

314
00:16:57,530 --> 00:17:00,040
once we are done with the
relaxation step-- that

315
00:17:00,040 --> 00:17:07,630
equals d v. This part
here equals d v. OK?

316
00:17:07,630 --> 00:17:09,440
That's how that works.

317
00:17:09,440 --> 00:17:11,150
So that's good news.

318
00:17:11,150 --> 00:17:15,276
We have a relaxation
algorithm that is safe.

319
00:17:15,276 --> 00:17:16,650
We can now
arbitrarily, and we'll

320
00:17:16,650 --> 00:17:21,520
do this for all of algorithms
we look at, really.

321
00:17:21,520 --> 00:17:23,980
At least in 006,
for shortest paths.

322
00:17:23,980 --> 00:17:27,560
Which applies some
sequence of relaxations.

323
00:17:27,560 --> 00:17:31,516
And, depending on the
special case of the problem,

324
00:17:31,516 --> 00:17:33,640
we're going to apply these
things in different ways

325
00:17:33,640 --> 00:17:36,310
to get the most
efficient algorithm.

326
00:17:36,310 --> 00:17:37,200
All right?

327
00:17:37,200 --> 00:17:40,890
So, we can now do algorithms.

328
00:17:40,890 --> 00:17:43,715
Let's look at DAGs first.

329
00:17:43,715 --> 00:17:53,670

330
00:17:53,670 --> 00:17:58,390
So, DAG stands for
Directed Acyclic Graphs.

331
00:17:58,390 --> 00:18:08,430
So that means we
can't have cycles.

332
00:18:08,430 --> 00:18:10,310
So we can't have
negative cycles.

333
00:18:10,310 --> 00:18:13,410
So that's why this is an
interesting special case.

334
00:18:13,410 --> 00:18:15,470
It makes things a
little bit easier for us

335
00:18:15,470 --> 00:18:18,390
because we don't have to
worry about negative cycles.

336
00:18:18,390 --> 00:18:20,280
We're actually going
to look at DAGs

337
00:18:20,280 --> 00:18:22,275
that have negative
edges in them.

338
00:18:22,275 --> 00:18:22,820
All right?

339
00:18:22,820 --> 00:18:26,090
So, we're allowed to have
negative edges in these DAGs.

340
00:18:26,090 --> 00:18:27,730
But we don't have
negative cycles.

341
00:18:27,730 --> 00:18:29,284
And, as I said
last time, it's not

342
00:18:29,284 --> 00:18:30,950
the negative edges
that cause a problem.

343
00:18:30,950 --> 00:18:34,266
If you only go through
at negative edge once,

344
00:18:34,266 --> 00:18:35,640
you can just
subtract that value.

345
00:18:35,640 --> 00:18:36,910
And it's cool.

346
00:18:36,910 --> 00:18:38,960
It's only when you
get into a situation

347
00:18:38,960 --> 00:18:41,370
where you're going
through a negative edge,

348
00:18:41,370 --> 00:18:42,360
a negative cycle.

349
00:18:42,360 --> 00:18:45,960
And you can just iterate through
them to get to minus infinity.

350
00:18:45,960 --> 00:18:49,840
And you have an indeterminate
shortest path value.

351
00:18:49,840 --> 00:18:54,320
So the way this is going
to work-- if you ever

352
00:18:54,320 --> 00:18:56,820
have a DAG, by the way, the
first thing you want to try--

353
00:18:56,820 --> 00:18:58,820
and this is certainly
true in your problem set--

354
00:18:58,820 --> 00:19:01,840
when there's a question, try
to topologically sort it.

355
00:19:01,840 --> 00:19:02,430
OK?

356
00:19:02,430 --> 00:19:05,550
It's a fine hammer to
use, when you have a DAG.

357
00:19:05,550 --> 00:19:11,690
And it's not an exception here.

358
00:19:11,690 --> 00:19:13,500
To do shortest
paths, we're going

359
00:19:13,500 --> 00:19:17,760
to topologically sort the DAG.

360
00:19:17,760 --> 00:19:32,770
And the path from u
to v implies that u

361
00:19:32,770 --> 00:19:37,500
is before v in the ordering.

362
00:19:37,500 --> 00:19:41,820

363
00:19:41,820 --> 00:19:43,692
And, once you do that,
you have this linear.

364
00:19:43,692 --> 00:19:44,900
And I'll show you an example.

365
00:19:44,900 --> 00:19:46,510
You have this linear ordering.

366
00:19:46,510 --> 00:19:49,080
And we're just going to
go through, in order,

367
00:19:49,080 --> 00:19:51,162
from left to right,
relaxing these edges.

368
00:19:51,162 --> 00:19:52,620
And we're going to
get our shortest

369
00:19:52,620 --> 00:19:55,240
paths for all the vertices.

370
00:19:55,240 --> 00:20:01,080
So, the second and last step
is, one pass, left to right,

371
00:20:01,080 --> 00:20:07,460
over the vertices, in
topologically sorted order.

372
00:20:07,460 --> 00:20:17,000

373
00:20:17,000 --> 00:20:20,570
And we're going to
relax each edge that

374
00:20:20,570 --> 00:20:22,124
leaves the particular
vertex we are

375
00:20:22,124 --> 00:20:23,290
trying to process right now.

376
00:20:23,290 --> 00:20:32,940

377
00:20:32,940 --> 00:20:36,990
And so, we know topological
sorting is order v plus e,

378
00:20:36,990 --> 00:20:38,660
includes depth-first search.

379
00:20:38,660 --> 00:20:41,460
And this pass over the vertices,
you're touching each vertex.

380
00:20:41,460 --> 00:20:44,490
And you're touching every edge
a constant number of times.

381
00:20:44,490 --> 00:20:45,970
In this case, once.

382
00:20:45,970 --> 00:20:53,180
So this is our first special
case shortest path algorithm.

383
00:20:53,180 --> 00:20:55,920
And that takes
order v plus e time.

384
00:20:55,920 --> 00:20:57,010
All right?

385
00:20:57,010 --> 00:20:58,570
Why does this work?

386
00:20:58,570 --> 00:21:06,150
And just one little
interesting aspect

387
00:21:06,150 --> 00:21:09,570
of this, which is
related to a DAG.

388
00:21:09,570 --> 00:21:14,810
And the relationship between the
DAG and the particular starting

389
00:21:14,810 --> 00:21:17,230
vertex that we're
going to be looking at.

390
00:21:17,230 --> 00:21:20,500
So, this is an example.

391
00:21:20,500 --> 00:21:23,570
Suppose I have a DAG like this.

392
00:21:23,570 --> 00:21:26,720
And I marked this vertex as s.

393
00:21:26,720 --> 00:21:30,020
And I want to find the
shortest path from s

394
00:21:30,020 --> 00:21:33,330
to these other nodes
that are a and b.

395
00:21:33,330 --> 00:21:36,280
Well, they don't exist, right?

396
00:21:36,280 --> 00:21:40,170
So, in this case, I'm
going to have a shortest

397
00:21:40,170 --> 00:21:42,410
path to a being infinity
and shortest path to b

398
00:21:42,410 --> 00:21:43,710
being infinity.

399
00:21:43,710 --> 00:21:46,080
And this is a trivial example.

400
00:21:46,080 --> 00:21:48,330
So, this algorithm is general.

401
00:21:48,330 --> 00:21:51,730
It doesn't say anything about
what the starting vertex is.

402
00:21:51,730 --> 00:21:52,230
Right?

403
00:21:52,230 --> 00:21:55,300
It should work for any
choice of starting vertex.

404
00:21:55,300 --> 00:22:00,530
The nice thing is that you
can do the topological sort.

405
00:22:00,530 --> 00:22:05,460
And then you can commit to
what the starting vertex is.

406
00:22:05,460 --> 00:22:08,890
And you can go off, and you can
say, from this starting vertex,

407
00:22:08,890 --> 00:22:11,600
I'm going to go and
compute the shortest paths

408
00:22:11,600 --> 00:22:15,340
to the other vertices
that I can actually reach.

409
00:22:15,340 --> 00:22:16,050
OK?

410
00:22:16,050 --> 00:22:19,640
So let's say that you had
a DAG that looks like this.

411
00:22:19,640 --> 00:22:21,640
All right, once you've
topologically sorted it,

412
00:22:21,640 --> 00:22:27,087
you can always draw
a DAG in linear form.

413
00:22:27,087 --> 00:22:27,920
That's a nice thing.

414
00:22:27,920 --> 00:22:37,912

415
00:22:37,912 --> 00:22:39,870
I'm going to put edge
weights down in a minute.

416
00:22:39,870 --> 00:22:48,150

417
00:22:48,150 --> 00:22:48,650
All right.

418
00:22:48,650 --> 00:22:49,620
So that's my DAG.

419
00:22:49,620 --> 00:22:52,880

420
00:22:52,880 --> 00:22:53,380
Let's see.

421
00:22:53,380 --> 00:23:04,160
5, 3, 2, 6, 7, 4,
2, minus 1, minus 2.

422
00:23:04,160 --> 00:23:07,970

423
00:23:07,970 --> 00:23:09,240
So that's my DAG.

424
00:23:09,240 --> 00:23:12,840
And I've drawn it in
topologically sorted form.

425
00:23:12,840 --> 00:23:14,300
And I go left to right.

426
00:23:14,300 --> 00:23:19,080
Now, let's say that, at this
point, I get to step two.

427
00:23:19,080 --> 00:23:20,810
And I want to find
shortest paths.

428
00:23:20,810 --> 00:23:23,490
Now, I have to say,
what is my source?

429
00:23:23,490 --> 00:23:28,850
And, if I just happen to
have this as my source,

430
00:23:28,850 --> 00:23:31,160
well, there's
nothing to do here.

431
00:23:31,160 --> 00:23:33,440
There's no edges
that go out of this.

432
00:23:33,440 --> 00:23:36,510
And so that means that
everything to the left of me

433
00:23:36,510 --> 00:23:37,930
is infinity.

434
00:23:37,930 --> 00:23:38,740
OK?

435
00:23:38,740 --> 00:23:40,590
So the first thing
that you do is,

436
00:23:40,590 --> 00:23:44,180
you say, find the
source that corresponds

437
00:23:44,180 --> 00:23:46,790
to the starting vertex.

438
00:23:46,790 --> 00:23:50,210
And let's say, this is the
starting vertex, in this case.

439
00:23:50,210 --> 00:23:53,900
Which I'll mark in bold.

440
00:23:53,900 --> 00:23:55,120
So that's my starting vertex.

441
00:23:55,120 --> 00:23:57,060
I'll take a nontrivial case.

442
00:23:57,060 --> 00:23:59,570
And everything to
the left is going

443
00:23:59,570 --> 00:24:02,980
to get marked with infinity.

444
00:24:02,980 --> 00:24:07,020
And now, I've got to do
some work on relaxation.

445
00:24:07,020 --> 00:24:10,080
And I'm not going to get
the shortest path instantly

446
00:24:10,080 --> 00:24:14,530
for a particular vertex, once
I get to it, because there

447
00:24:14,530 --> 00:24:16,250
may be better ways
of getting there.

448
00:24:16,250 --> 00:24:18,350
And especially if I
have negative edges.

449
00:24:18,350 --> 00:24:21,970
And that's certainly possible,
that a longer length path

450
00:24:21,970 --> 00:24:24,230
is going to be
the shortest path.

451
00:24:24,230 --> 00:24:27,020
But what I'll do is take s.

452
00:24:27,020 --> 00:24:30,610
And I'm going to relax
edges that emanate from s.

453
00:24:30,610 --> 00:24:32,520
And so, step one,
all of these are

454
00:24:32,520 --> 00:24:34,350
going to be infinity
to start with.

455
00:24:34,350 --> 00:24:35,910
So everything is infinity.

456
00:24:35,910 --> 00:24:37,780
The ones to the
left stay infinity.

457
00:24:37,780 --> 00:24:40,500
The ones to the right are
going to be reachable.

458
00:24:40,500 --> 00:24:47,110
And you're going to
update those values.

459
00:24:47,110 --> 00:24:51,230
And so, when you go
like so, this becomes 2.

460
00:24:51,230 --> 00:24:52,970
This becomes 6.

461
00:24:52,970 --> 00:24:54,350
As I follow that.

462
00:24:54,350 --> 00:24:58,940
And I'm done with
this vertex, s.

463
00:24:58,940 --> 00:25:00,160
And this is what I have.

464
00:25:00,160 --> 00:25:01,310
2 and 6.

465
00:25:01,310 --> 00:25:04,560
So the next step is
to get to this vertex.

466
00:25:04,560 --> 00:25:06,770
Let's call that the vertex a.

467
00:25:06,770 --> 00:25:09,900
And I'm going relax the
edges going out of a.

468
00:25:09,900 --> 00:25:14,560
And, when I go out
of a, I get 2 plus 7

469
00:25:14,560 --> 00:25:17,010
is 9, which is greater than 6.

470
00:25:17,010 --> 00:25:19,260
So there's no reason
to update that.

471
00:25:19,260 --> 00:25:22,840
2 plus 4 is less than infinity.

472
00:25:22,840 --> 00:25:26,750
And so, that's 6.

473
00:25:26,750 --> 00:25:31,140
2 plus 2 gives me 4 here.

474
00:25:31,140 --> 00:25:32,740
And so on and so forth.

475
00:25:32,740 --> 00:25:34,710
So then, now I'm
done with vertex a.

476
00:25:34,710 --> 00:25:39,020
If this vertex is b, then I
have a value of 6 for this.

477
00:25:39,020 --> 00:25:42,255
And 6 minus 1 is less than 6.

478
00:25:42,255 --> 00:25:44,810
So this becomes 5.

479
00:25:44,810 --> 00:25:49,930
And 5 minus 2-- well, that's
the next step after that.

480
00:25:49,930 --> 00:25:52,630
I haven't put-- this is a 1.

481
00:25:52,630 --> 00:25:55,717
And so 6 plus 1 is 7.

482
00:25:55,717 --> 00:25:56,800
But that's greater than 4.

483
00:25:56,800 --> 00:25:58,870
So we don't have
to anything there.

484
00:25:58,870 --> 00:26:05,410
So the final values that I end
up getting are 3 for this one.

485
00:26:05,410 --> 00:26:07,230
So this is the final value.

486
00:26:07,230 --> 00:26:09,840
5 is the final value here.

487
00:26:09,840 --> 00:26:12,090
6 is the final value here.

488
00:26:12,090 --> 00:26:14,020
2 is the final value here.

489
00:26:14,020 --> 00:26:15,650
And that one is 0.

490
00:26:15,650 --> 00:26:17,460
And this stays infinity.

491
00:26:17,460 --> 00:26:18,470
OK?

492
00:26:18,470 --> 00:26:20,680
So fairly straightforward.

493
00:26:20,680 --> 00:26:22,560
Do a topological sort.

494
00:26:22,560 --> 00:26:24,180
Find the starting point.

495
00:26:24,180 --> 00:26:27,130
And then run all the
way to the right.

496
00:26:27,130 --> 00:26:30,580
Interestingly, this is actually
a really simple example

497
00:26:30,580 --> 00:26:33,150
of dynamic programming,
which we'll talk about

498
00:26:33,150 --> 00:26:36,460
in gory detail,
later in November.

499
00:26:36,460 --> 00:26:44,250
But what I have here is
the simplest special case

500
00:26:44,250 --> 00:26:48,160
of a graph that has an
order of v e [INAUDIBLE]

501
00:26:48,160 --> 00:26:49,430
shortest path algorithm.

502
00:26:49,430 --> 00:26:52,120
And the reason for that
is we don't have cycles.

503
00:26:52,120 --> 00:26:53,150
All right?

504
00:26:53,150 --> 00:26:55,220
Any questions about this?

505
00:26:55,220 --> 00:26:57,630
People buy this?

506
00:26:57,630 --> 00:26:58,450
It works?

507
00:26:58,450 --> 00:26:59,370
OK.

508
00:26:59,370 --> 00:27:02,260
So, we've got one
algorithm under our belt.

509
00:27:02,260 --> 00:27:05,080
And we look at, really,
a more interesting case

510
00:27:05,080 --> 00:27:08,380
because most graphs are
going to have cycles in them.

511
00:27:08,380 --> 00:27:12,090
But we will stay
with the special case

512
00:27:12,090 --> 00:27:13,340
of no negative edges, now.

513
00:27:13,340 --> 00:27:13,840
All right?

514
00:27:13,840 --> 00:27:18,720
So Dijkstra's algorithm doesn't
work for negative edges.

515
00:27:18,720 --> 00:27:20,070
So it's different.

516
00:27:20,070 --> 00:27:23,150
This algorithm is not
subsumed by Dijkstra.

517
00:27:23,150 --> 00:27:25,100
That's important to understand.

518
00:27:25,100 --> 00:27:28,340
So Dijkstra's algorithm
works for graphs with cycles.

519
00:27:28,340 --> 00:27:32,740
But all of the edge ways have
to be either 0 or positive.

520
00:27:32,740 --> 00:27:35,740
This algorithm works for DAGs
that can have negative edges.

521
00:27:35,740 --> 00:27:37,340
But you can't have cycles.

522
00:27:37,340 --> 00:27:40,450
So both of these algorithms
have their place under the sun.

523
00:27:40,450 --> 00:27:43,330

524
00:27:43,330 --> 00:27:46,230
So, let's take a look
at Dijkstra's algorithm.

525
00:27:46,230 --> 00:27:48,010
Actually, I guess I have a demo.

526
00:27:48,010 --> 00:27:57,390
So, the one demo
we have in 6006.

527
00:27:57,390 --> 00:28:00,460
[INAUDIBLE] Dijkstra is a very
straightforward algorithm.

528
00:28:00,460 --> 00:28:04,590
It's not trivial to
prove its correctness.

529
00:28:04,590 --> 00:28:07,770
But from a standpoint of
coding, from a standpoint

530
00:28:07,770 --> 00:28:10,640
of understanding the flow,
it's a very straightforward

531
00:28:10,640 --> 00:28:12,020
algorithm.

532
00:28:12,020 --> 00:28:14,060
One of the reasons
why that's the case

533
00:28:14,060 --> 00:28:17,260
is because it's a
greedy algorithm.

534
00:28:17,260 --> 00:28:21,710
It does things incrementally,
maximizing the benefit,

535
00:28:21,710 --> 00:28:22,780
as you will.

536
00:28:22,780 --> 00:28:26,000
And intuitively builds
the shortest paths.

537
00:28:26,000 --> 00:28:28,770
And it goes vertex by vertex.

538
00:28:28,770 --> 00:28:31,410
So here's a demo
of Dijkstra, which,

539
00:28:31,410 --> 00:28:33,419
the reason I want
to show you this,

540
00:28:33,419 --> 00:28:35,960
is because it will give you some
intuition as to why Dijkstra

541
00:28:35,960 --> 00:28:36,753
works.

542
00:28:36,753 --> 00:28:41,040
Now, some points of note.

543
00:28:41,040 --> 00:28:43,070
I can't tilt this more
than about this much

544
00:28:43,070 --> 00:28:45,150
because then these
balls will fall off.

545
00:28:45,150 --> 00:28:49,180
So, cameraman, can you get this?

546
00:28:49,180 --> 00:28:49,680
All right?

547
00:28:49,680 --> 00:28:52,270
For posterity.

548
00:28:52,270 --> 00:28:55,440
So I got an undirected
graph here, right?

549
00:28:55,440 --> 00:28:58,480
And each of these
things are nodes.

550
00:28:58,480 --> 00:29:01,200
The balls are the
nodes of the vertices.

551
00:29:01,200 --> 00:29:03,010
And I've drawn the
picture over there.

552
00:29:03,010 --> 00:29:04,280
And G stands for green.

553
00:29:04,280 --> 00:29:06,350
And Y stands for
yellow, et cetera.

554
00:29:06,350 --> 00:29:09,080
So, this graph is essentially
what I have up there.

555
00:29:09,080 --> 00:29:16,540
And I've put strings connecting
these balls, associated

556
00:29:16,540 --> 00:29:21,970
with the weights that
you see up there.

557
00:29:21,970 --> 00:29:25,700
So, if I got this
right, the string

558
00:29:25,700 --> 00:29:30,190
that's connecting the green ball
to the yellow ball up on top

559
00:29:30,190 --> 00:29:31,860
is 19 centimeters.

560
00:29:31,860 --> 00:29:33,935
And so on and so forth
for these other ones.

561
00:29:33,935 --> 00:29:35,250
All right?

562
00:29:35,250 --> 00:29:37,800
So, that's Dijkstra.

563
00:29:37,800 --> 00:29:41,610
And what do you
think I have to do

564
00:29:41,610 --> 00:29:46,209
to compute shortest paths,
mechanically speaking?

565
00:29:46,209 --> 00:29:47,500
What do you think I have to do?

566
00:29:47,500 --> 00:29:50,248

567
00:29:50,248 --> 00:29:51,110
Yeah, someone.

568
00:29:51,110 --> 00:29:53,741

569
00:29:53,741 --> 00:29:55,532
AUDIENCE: Pick up the
green ball and just--

570
00:29:55,532 --> 00:29:56,630
PROFESSOR: Pick up the
ball and lift it up.

571
00:29:56,630 --> 00:29:57,171
That's right.

572
00:29:57,171 --> 00:29:58,020
Good.

573
00:29:58,020 --> 00:30:00,250
It's worth a cushion.

574
00:30:00,250 --> 00:30:02,090
All right, so, let's
all this works.

575
00:30:02,090 --> 00:30:05,760

576
00:30:05,760 --> 00:30:10,720
So, first, let me show you by
those values that I have there.

577
00:30:10,720 --> 00:30:15,730
If the green ball is the
starting vertex, then

578
00:30:15,730 --> 00:30:21,790
the shortest path to the
purple vertex, p, is 7.

579
00:30:21,790 --> 00:30:24,530
And that's the
closest node to G.

580
00:30:24,530 --> 00:30:27,360
And then, the next
closest node is

581
00:30:27,360 --> 00:30:30,540
the blue one, which
is b, which is 12.

582
00:30:30,540 --> 00:30:31,830
7 plus 5.

583
00:30:31,830 --> 00:30:33,210
And so on and so forth.

584
00:30:33,210 --> 00:30:35,890
And so, if this all works,
and I haven't tried this out,

585
00:30:35,890 --> 00:30:37,930
because this is a one use demo.

586
00:30:37,930 --> 00:30:41,780
Once I pull this up, the
strings get so tangled up,

587
00:30:41,780 --> 00:30:42,860
it doesn't work anymore.

588
00:30:42,860 --> 00:30:43,440
All right?

589
00:30:43,440 --> 00:30:46,090
So that's why I had to do
all of this, lug these over.

590
00:30:46,090 --> 00:30:47,780
Otherwise, it'd
be-- so this is not

591
00:30:47,780 --> 00:30:49,335
a computer reversible
kind of thing.

592
00:30:49,335 --> 00:30:51,340
So, if you want to
code Dijkstra up.

593
00:30:51,340 --> 00:30:54,670
OK, so if I just lift
it up, and if I do that,

594
00:30:54,670 --> 00:30:56,337
and if I tilt it in
the right direction.

595
00:30:56,337 --> 00:30:56,836
Yeah.

596
00:30:56,836 --> 00:30:57,520
I want to that.

597
00:30:57,520 --> 00:30:59,720
So you can see that this is a
little bit of fudging going on

598
00:30:59,720 --> 00:31:01,530
here, with respect to
getting this right.

599
00:31:01,530 --> 00:31:03,115
But you see green is up on top.

600
00:31:03,115 --> 00:31:04,490
And what is the
next one you see?

601
00:31:04,490 --> 00:31:05,010
AUDIENCE: Purple.

602
00:31:05,010 --> 00:31:05,450
PROFESSOR: Purple.

603
00:31:05,450 --> 00:31:05,969
That's good.

604
00:31:05,969 --> 00:31:07,135
What's the next one you see?

605
00:31:07,135 --> 00:31:07,450
AUDIENCE: Blue.

606
00:31:07,450 --> 00:31:08,116
PROFESSOR: Blue.

607
00:31:08,116 --> 00:31:10,220
That's good.

608
00:31:10,220 --> 00:31:14,680
Y, and then R. And
strings that are taught,

609
00:31:14,680 --> 00:31:18,310
that have tension in them, are
the predecessor vertices, OK?

610
00:31:18,310 --> 00:31:19,880
That's the pie.

611
00:31:19,880 --> 00:31:20,440
All right?

612
00:31:20,440 --> 00:31:23,350
So, again, I computed the
shortest paths, right?

613
00:31:23,350 --> 00:31:24,340
Mechanically.

614
00:31:24,340 --> 00:31:27,660
And, if I could have a way
of measuring the tension

615
00:31:27,660 --> 00:31:30,921
on the strings, I have my pie,
my predecessor relationship,

616
00:31:30,921 --> 00:31:31,420
as well.

617
00:31:31,420 --> 00:31:32,060
All right?

618
00:31:32,060 --> 00:31:33,972
Now, let's see if this works.

619
00:31:33,972 --> 00:31:35,090
This works, right?

620
00:31:35,090 --> 00:31:40,270
So, if the second thing doesn't
work, don't hold it against me.

621
00:31:40,270 --> 00:31:44,950
But, let's say if I take R,
and I lift it up like that.

622
00:31:44,950 --> 00:31:46,810
Yikes.

623
00:31:46,810 --> 00:31:50,430
So, R, followed by Y,
followed by B, followed by P,

624
00:31:50,430 --> 00:31:51,490
followed by G.

625
00:31:51,490 --> 00:31:52,820
Hey.

626
00:31:52,820 --> 00:31:54,560
Come on.

627
00:31:54,560 --> 00:31:55,170
All right?

628
00:31:55,170 --> 00:31:55,670
This works.

629
00:31:55,670 --> 00:31:56,180
Thank you.

630
00:31:56,180 --> 00:31:57,422
Thank you.

631
00:31:57,422 --> 00:31:59,290
All right.

632
00:31:59,290 --> 00:32:06,750
So there's actually a
reason why I did that demo.

633
00:32:06,750 --> 00:32:09,600
There's a greedy algorithm here.

634
00:32:09,600 --> 00:32:11,390
And, I guess, greedy is gravity.

635
00:32:11,390 --> 00:32:11,890
Right?

636
00:32:11,890 --> 00:32:13,830
Gravity is greedy.

637
00:32:13,830 --> 00:32:16,904
So, obviously, the reason
why those balls are hanging

638
00:32:16,904 --> 00:32:18,070
is because they have weight.

639
00:32:18,070 --> 00:32:19,140
And they have gravity.

640
00:32:19,140 --> 00:32:21,812
And you can imagine that you
could now-- people in physics.

641
00:32:21,812 --> 00:32:23,520
I don't know anybody
majoring in physics.

642
00:32:23,520 --> 00:32:26,300
Anyone double majoring in
physics or something here?

643
00:32:26,300 --> 00:32:27,980
All right.

644
00:32:27,980 --> 00:32:30,000
So, you know your Newton's
laws of mechanics.

645
00:32:30,000 --> 00:32:31,900
And you know about
gravity, and all of that.

646
00:32:31,900 --> 00:32:33,780
So you can imagine that
you said, you know,

647
00:32:33,780 --> 00:32:36,775
the heck with all this priority
queue stuff in the problem set.

648
00:32:36,775 --> 00:32:38,150
In the algorithm
that we're going

649
00:32:38,150 --> 00:32:39,660
to be talking
about for Dijkstra,

650
00:32:39,660 --> 00:32:43,770
I'm going to do a kinetic
simulation of shortest paths

651
00:32:43,770 --> 00:32:47,791
in order to get the actual
values of these shortest paths.

652
00:32:47,791 --> 00:32:48,290
OK?

653
00:32:48,290 --> 00:32:49,790
Now, that would be cool.

654
00:32:49,790 --> 00:32:51,730
But it'd be horribly slow.

655
00:32:51,730 --> 00:32:54,660
And so, the Dijkstra algorithm
we're going to be talking about

656
00:32:54,660 --> 00:32:57,980
is going to just compute the
steady state, corresponding

657
00:32:57,980 --> 00:33:04,810
to the closest vertex that
is closest to G. All right?

658
00:33:04,810 --> 00:33:07,670
So Dijkstra, the algorithm,
the intuition behind it,

659
00:33:07,670 --> 00:33:10,710
is that it's going to greedily
construct shortest paths.

660
00:33:10,710 --> 00:33:12,650
And it's going to
be starting with G,

661
00:33:12,650 --> 00:33:13,982
which is your source vertex.

662
00:33:13,982 --> 00:33:15,440
And then, the first
thing that it's

663
00:33:15,440 --> 00:33:17,455
going to process, and
find the shortest path to

664
00:33:17,455 --> 00:33:19,220
is going to be
the purple vertex.

665
00:33:19,220 --> 00:33:20,070
And then the blue.

666
00:33:20,070 --> 00:33:21,120
And then the yellow.

667
00:33:21,120 --> 00:33:21,940
And then the red.

668
00:33:21,940 --> 00:33:22,440
All right?

669
00:33:22,440 --> 00:33:26,530
So it actually mimics, to
some extent, this demo.

670
00:33:26,530 --> 00:33:29,762
All right?

671
00:33:29,762 --> 00:33:31,970
So, let's take a look at
the pseudocode for Dijkstra.

672
00:33:31,970 --> 00:34:00,090

673
00:34:00,090 --> 00:34:01,290
So, g is your graph.

674
00:34:01,290 --> 00:34:03,050
w are the weights.

675
00:34:03,050 --> 00:34:06,760
Small s is the starting vertex.

676
00:34:06,760 --> 00:34:16,370
We're going to initialize g
and s, which means we just mark

677
00:34:16,370 --> 00:34:18,330
s a starting vertex.

678
00:34:18,330 --> 00:34:22,780
And we're going to also have
this capital S, that I'll

679
00:34:22,780 --> 00:34:27,050
use these little bars to
differentiate from small s.

680
00:34:27,050 --> 00:34:28,199
So this is a set.

681
00:34:28,199 --> 00:34:30,880
Capital S is a set.

682
00:34:30,880 --> 00:34:33,590
And we're going to
initialize that to null.

683
00:34:33,590 --> 00:34:36,170
And there's another
set called Q,

684
00:34:36,170 --> 00:34:40,400
which is initialized to
the entire set of vertices.

685
00:34:40,400 --> 00:34:43,110
And all this means is
that, initially, we

686
00:34:43,110 --> 00:34:44,420
haven't done any processing.

687
00:34:44,420 --> 00:34:49,230
And we don't know the
shortest paths to any vertex

688
00:34:49,230 --> 00:34:52,860
because this set of
vertices is null.

689
00:34:52,860 --> 00:34:56,310
And Q is the set of vertices
that need to be processed.

690
00:34:56,310 --> 00:34:59,560
And, as we start
processing vertices from Q,

691
00:34:59,560 --> 00:35:01,960
we're going to move
them to capital S.

692
00:35:01,960 --> 00:35:04,480
And they're going to
contain the set of vertices

693
00:35:04,480 --> 00:35:08,660
that we know the shortest
paths to already.

694
00:35:08,660 --> 00:35:10,960
And that's the invariant
in this algorithm.

695
00:35:10,960 --> 00:35:13,422
s is going to contain
the set of vertices

696
00:35:13,422 --> 00:35:14,880
that we know the
shortest paths to.

697
00:35:14,880 --> 00:35:17,440

698
00:35:17,440 --> 00:35:22,970
And so, Dijkstra is
a little while loop

699
00:35:22,970 --> 00:35:24,740
that says, while
they're vertices

700
00:35:24,740 --> 00:35:32,300
that need to be processed,
then I'm going to take u.

701
00:35:32,300 --> 00:35:46,190
And I'm going to
extract-min from Q.

702
00:35:46,190 --> 00:35:54,410
And this is going
to delete u from Q.

703
00:35:54,410 --> 00:35:58,430
And this
initialization-- and this

704
00:35:58,430 --> 00:36:05,240
is a small s here-- is
going to set d of s to be 0.

705
00:36:05,240 --> 00:36:07,170
That's all this
initialization does.

706
00:36:07,170 --> 00:36:08,930
Because that's all we know.

707
00:36:08,930 --> 00:36:10,334
We have a starting vertex.

708
00:36:10,334 --> 00:36:12,750
And we know that the shortest
path to the starting vertex,

709
00:36:12,750 --> 00:36:15,240
from the starting vertex, is 0.

710
00:36:15,240 --> 00:36:18,150
So, all that means is
that, all of the other ones

711
00:36:18,150 --> 00:36:19,700
have infinity values.

712
00:36:19,700 --> 00:36:22,060
So, at this very first
step, it makes sense

713
00:36:22,060 --> 00:36:24,730
that extract-min
Q is going to pull

714
00:36:24,730 --> 00:36:27,670
the starting vertex,
small s, out.

715
00:36:27,670 --> 00:36:31,660
And is going to assign
it to this u value.

716
00:36:31,660 --> 00:36:35,040
And we're going to
set s to be-- capital

717
00:36:35,040 --> 00:36:42,520
S-- to be capital S union u.

718
00:36:42,520 --> 00:36:49,350
And then, all we have to do is
relax the edges from the vertex

719
00:36:49,350 --> 00:36:50,640
that we just added.

720
00:36:50,640 --> 00:36:57,910
So, for each vertex, v
belonging to adjacent

721
00:36:57,910 --> 00:37:00,670
s, so that you can reach from u.

722
00:37:00,670 --> 00:37:05,788
We relax u, v, w.

723
00:37:05,788 --> 00:37:08,476

724
00:37:08,476 --> 00:37:09,380
All right?

725
00:37:09,380 --> 00:37:10,060
That's it.

726
00:37:10,060 --> 00:37:10,916
That's Dijkstra.

727
00:37:10,916 --> 00:37:14,890

728
00:37:14,890 --> 00:37:17,460
It's a greedy algorithm.

729
00:37:17,460 --> 00:37:18,930
It's iterative.

730
00:37:18,930 --> 00:37:21,690
And the reason it's greedy
is because of this step here.

731
00:37:21,690 --> 00:37:25,590
It's just picking
the min priority

732
00:37:25,590 --> 00:37:30,760
from the un-processed
vertices, Q. And, essentially,

733
00:37:30,760 --> 00:37:37,590
claiming that this min value
is something that you already

734
00:37:37,590 --> 00:37:40,160
computed the shortest paths for.

735
00:37:40,160 --> 00:37:42,800
So, when you're putting
something into S,

736
00:37:42,800 --> 00:37:45,110
you're saying, I'm done.

737
00:37:45,110 --> 00:37:48,220
I know the shortest path
to this particular vertex.

738
00:37:48,220 --> 00:37:51,580
And I need to now process
it, in the sense that I

739
00:37:51,580 --> 00:37:55,250
have to relax the edges that
are coming out of this vertex.

740
00:37:55,250 --> 00:37:58,610
And update the priority
values because relax

741
00:37:58,610 --> 00:38:02,780
is going to go change
the d values, as we know,

742
00:38:02,780 --> 00:38:07,280
corresponding to the vertex,
v. It might change the value.

743
00:38:07,280 --> 00:38:08,310
It might not.

744
00:38:08,310 --> 00:38:10,950
But there's a possibility
that it would.

745
00:38:10,950 --> 00:38:13,280
And you're going to do
this for all of the edges

746
00:38:13,280 --> 00:38:15,937
that are emanating
out of the vertex, u.

747
00:38:15,937 --> 00:38:18,270
And so you may be changing a
bunch of different priority

748
00:38:18,270 --> 00:38:18,770
values.

749
00:38:18,770 --> 00:38:20,940
So the next time
around, you will

750
00:38:20,940 --> 00:38:27,270
get a different minimum
priority vertex.

751
00:38:27,270 --> 00:38:27,970
For two reasons.

752
00:38:27,970 --> 00:38:31,050
One is that you've extracted
out the minimum priority vertex.

753
00:38:31,050 --> 00:38:34,150
You've deleted it from
Q. And the second reason

754
00:38:34,150 --> 00:38:36,340
is that these
priority values change

755
00:38:36,340 --> 00:38:38,200
as you go through the loop.

756
00:38:38,200 --> 00:38:39,110
All right?

757
00:38:39,110 --> 00:38:41,960
And so, in our demo,
essentially what happened was,

758
00:38:41,960 --> 00:38:46,120
the first time, the process
of lifting the green vertex,

759
00:38:46,120 --> 00:38:49,220
corresponding to choosing
it as a starting vertex.

760
00:38:49,220 --> 00:38:51,570
And the first thing
that was closest

761
00:38:51,570 --> 00:38:55,550
to it, which had the taught
string hanging from it,

762
00:38:55,550 --> 00:38:57,174
has the min priority value.

763
00:38:57,174 --> 00:38:58,090
And you pull that out.

764
00:38:58,090 --> 00:39:01,420
And then so on and so
forth, as you go down.

765
00:39:01,420 --> 00:39:04,445
And I'm not going to go
through and prove this.

766
00:39:04,445 --> 00:39:06,570
But it's certainly something
that is worth reading.

767
00:39:06,570 --> 00:39:10,610
It's half of page proof,
maybe a page in CLRS.

768
00:39:10,610 --> 00:39:12,480
And you should read
the proof for Dijkstra,

769
00:39:12,480 --> 00:39:13,791
the formal proof for Dijkstra.

770
00:39:13,791 --> 00:39:15,790
Which just, essentially,
does all the accounting

771
00:39:15,790 --> 00:39:16,940
and gets things right.

772
00:39:16,940 --> 00:39:20,290
And uses the lemma that we have,
with respect to the relaxation

773
00:39:20,290 --> 00:39:24,540
operation being safe.

774
00:39:24,540 --> 00:39:25,370
OK?

775
00:39:25,370 --> 00:39:26,770
Any questions about Dijkstra?

776
00:39:26,770 --> 00:39:29,141
Or about the pseudocode,
in particular?

777
00:39:29,141 --> 00:39:31,390
I guess you guys are going
to code this at some point.

778
00:39:31,390 --> 00:39:31,600
Yeah?

779
00:39:31,600 --> 00:39:33,350
AUDIENCE: How are the
vertices comparable?

780
00:39:33,350 --> 00:39:34,250
In what way?

781
00:39:34,250 --> 00:39:36,015
PROFESSOR: Oh, so
that's a good question.

782
00:39:36,015 --> 00:39:37,515
And I should have
made that clearer.

783
00:39:37,515 --> 00:39:40,810

784
00:39:40,810 --> 00:39:43,420
So, Q is a priority queue.

785
00:39:43,420 --> 00:39:47,840
And the priorities of the
vertices are the d values, OK?

786
00:39:47,840 --> 00:39:52,890

787
00:39:52,890 --> 00:39:55,900
s being null is clear, I hope.

788
00:39:55,900 --> 00:39:56,920
That's clear.

789
00:39:56,920 --> 00:39:59,580
And then Q being the set of
vertices are clear, as well.

790
00:39:59,580 --> 00:40:03,030
Now, Q is a priority queue, OK?

791
00:40:03,030 --> 00:40:06,530
And we'll talk about how
we'll implement this priority

792
00:40:06,530 --> 00:40:08,570
queue, and the
complexity of Dijkstra,

793
00:40:08,570 --> 00:40:09,840
before we're done here.

794
00:40:09,840 --> 00:40:12,440
But, as an ADT, as an
Abstract Data Type,

795
00:40:12,440 --> 00:40:14,230
think of Q as being
a priority queue.

796
00:40:14,230 --> 00:40:15,650
And there's
priorities associated

797
00:40:15,650 --> 00:40:19,650
with each vertex that's in Q.
And these priorities change.

798
00:40:19,650 --> 00:40:21,211
And they're the d values.

799
00:40:21,211 --> 00:40:21,710
All right?

800
00:40:21,710 --> 00:40:22,460
So the priorities.

801
00:40:22,460 --> 00:40:30,720

802
00:40:30,720 --> 00:40:34,860
So, initially, d of
s-- small s-- is 0.

803
00:40:34,860 --> 00:40:37,280
And all of the other
ones are infinity.

804
00:40:37,280 --> 00:40:39,350
So it's clear that, the
very first time, you're

805
00:40:39,350 --> 00:40:42,590
going to set u to be small s,
which is a starting vertex.

806
00:40:42,590 --> 00:40:44,980
And then you relax the
edges coming out of s,

807
00:40:44,980 --> 00:40:47,890
potentially change some of
these other infinity values

808
00:40:47,890 --> 00:40:49,530
of the vertices
that you can reach

809
00:40:49,530 --> 00:40:51,850
from s to be less than infinity.

810
00:40:51,850 --> 00:40:55,420
And you're going
to, essentially,

811
00:40:55,420 --> 00:40:58,580
change the values of
the priority queue.

812
00:40:58,580 --> 00:40:59,187
And go around.

813
00:40:59,187 --> 00:41:01,020
And then select the min
value the next time.

814
00:41:01,020 --> 00:41:02,230
And so on and so forth.

815
00:41:02,230 --> 00:41:03,860
OK?

816
00:41:03,860 --> 00:41:04,860
Thanks for the question.

817
00:41:04,860 --> 00:41:05,693
Any other questions?

818
00:41:05,693 --> 00:41:09,320

819
00:41:09,320 --> 00:41:10,300
OK.

820
00:41:10,300 --> 00:41:19,350
So, let's just go through a
couple of steps in an example.

821
00:41:19,350 --> 00:41:22,700
I'm not going to go
through the whole thing.

822
00:41:22,700 --> 00:41:27,860
But you'll see an execution
of Dijkstra in the nodes.

823
00:41:27,860 --> 00:41:30,790
I think it's worth spending
just a couple of minutes going

824
00:41:30,790 --> 00:41:36,300
through the first few steps
of a Dijkstra execution.

825
00:41:36,300 --> 00:41:45,340
Just so how this priority
queue works is clear,

826
00:41:45,340 --> 00:41:48,740
let's take a look at a directed
graph that has five vertices.

827
00:41:48,740 --> 00:42:02,400

828
00:42:02,400 --> 00:42:03,110
So that's 7.

829
00:42:03,110 --> 00:42:14,040

830
00:42:14,040 --> 00:42:18,760
So let's start with a
being the starting vertex.

831
00:42:18,760 --> 00:42:21,490
And so d of a is 0.

832
00:42:21,490 --> 00:42:26,190
And d of b through
e are all infinity.

833
00:42:26,190 --> 00:42:31,580
Your s is null to begin with.

834
00:42:31,580 --> 00:42:35,100
And Q has all of the
five vertices in it.

835
00:42:35,100 --> 00:42:39,710

836
00:42:39,710 --> 00:42:43,721
So extract-min is
going to select a.

837
00:42:43,721 --> 00:42:46,830
That's the only one that is a 0.

838
00:42:46,830 --> 00:42:51,550
Because you've got 0, infinity,
infinity, infinity, infinity.

839
00:42:51,550 --> 00:42:56,130
And so, you select that,
and you set s to be a.

840
00:42:56,130 --> 00:42:57,970
And once you set s
to be a, you relax

841
00:42:57,970 --> 00:42:59,640
the edges coming out of a.

842
00:42:59,640 --> 00:43:01,000
And there's two of them.

843
00:43:01,000 --> 00:43:07,010
So you end up with 0, 10,
3, infinity, infinity.

844
00:43:07,010 --> 00:43:10,410
And the next extract-min
is going to select 3.

845
00:43:10,410 --> 00:43:14,820
And you're going to
set s to be a comma c.

846
00:43:14,820 --> 00:43:16,570
And so you're,
essentially, doing

847
00:43:16,570 --> 00:43:19,290
kind of a breadth-first search.

848
00:43:19,290 --> 00:43:21,100
But you're being greedy.

849
00:43:21,100 --> 00:43:23,230
It's a mixed breadth-first
depth-first search.

850
00:43:23,230 --> 00:43:24,730
You do a breadth-first
search when

851
00:43:24,730 --> 00:43:25,950
you're given a
particular vertex,

852
00:43:25,950 --> 00:43:27,408
and you look at
all of the vertices

853
00:43:27,408 --> 00:43:29,320
that you can reach
from that vertex.

854
00:43:29,320 --> 00:43:31,810
And then you say, I'm
a greedy algorithm.

855
00:43:31,810 --> 00:43:34,710
I'm going to pick the
vertex in this frontier

856
00:43:34,710 --> 00:43:37,660
that I've just created, that
is the shortest distance

857
00:43:37,660 --> 00:43:40,350
away from me, that has
the lowest priority value.

858
00:43:40,350 --> 00:43:43,030
And, in this case, it would be
c because this other one is 10.

859
00:43:43,030 --> 00:43:44,110
And this is shorter.

860
00:43:44,110 --> 00:43:44,610
Right?

861
00:43:44,610 --> 00:43:46,690
So that's why we
pick c over here.

862
00:43:46,690 --> 00:43:48,620
And one last one.

863
00:43:48,620 --> 00:43:52,940
Once you process c,
you're going to end up

864
00:43:52,940 --> 00:43:54,620
processing this
edge going out here.

865
00:43:54,620 --> 00:43:55,840
This edge going out there.

866
00:43:55,840 --> 00:43:57,560
This edge going out this way.

867
00:43:57,560 --> 00:44:05,070
And you're going to end
up with 0, 7, 3, 11, 5.

868
00:44:05,070 --> 00:44:08,280
And you've processed a bunch
of edges coming out of c.

869
00:44:08,280 --> 00:44:11,730
And, at this point, 0
is gone and 3 is gone.

870
00:44:11,730 --> 00:44:13,310
I'm just writing
the values here,

871
00:44:13,310 --> 00:44:14,890
just so you know what they are.

872
00:44:14,890 --> 00:44:17,670
But these are out of the picture
because, in s, those values

873
00:44:17,670 --> 00:44:18,920
should never change.

874
00:44:18,920 --> 00:44:21,500
Dijkstra essentially guarantees.

875
00:44:21,500 --> 00:44:23,100
And that's the
proof of correctness

876
00:44:23,100 --> 00:44:28,380
that takes a bit of doing,
is that this value is never

877
00:44:28,380 --> 00:44:29,620
going to reduce anymore.

878
00:44:29,620 --> 00:44:31,810
The pre-value is
never going to reduce.

879
00:44:31,810 --> 00:44:33,710
And it's been put into s.

880
00:44:33,710 --> 00:44:35,800
But what's remaining now is 5.

881
00:44:35,800 --> 00:44:39,090
And that corresponds
to the e vertex.

882
00:44:39,090 --> 00:44:45,130
So s becomes a, c, e.

883
00:44:45,130 --> 00:44:46,970
The 5 gets stuck in there.

884
00:44:46,970 --> 00:44:48,580
And so on and so forth.

885
00:44:48,580 --> 00:44:50,220
All right?

886
00:44:50,220 --> 00:44:51,712
So, that's Dijkstra.

887
00:44:51,712 --> 00:44:53,045
And now, let's start complexity.

888
00:44:53,045 --> 00:44:55,630

889
00:44:55,630 --> 00:44:58,640
So, it we have the code
for Dijkstra on the left,

890
00:44:58,640 --> 00:45:03,530
we have an ADT associated
with the priority queue.

891
00:45:03,530 --> 00:45:06,550
And now, we're back
to talking like we

892
00:45:06,550 --> 00:45:11,410
did early on in the term,
where we compared linked lists,

893
00:45:11,410 --> 00:45:15,170
and arrays, and
heaps, and trees.

894
00:45:15,170 --> 00:45:21,580
And said, for a particular
set of operations,

895
00:45:21,580 --> 00:45:24,020
which one is going
to be the best?

896
00:45:24,020 --> 00:45:25,130
OK?

897
00:45:25,130 --> 00:45:29,100
So, if you analyze Dijkstra,
and you look at the pseudocode

898
00:45:29,100 --> 00:45:34,320
first, and you say, what are the
operations that I'm performing?

899
00:45:34,320 --> 00:45:37,810

900
00:45:37,810 --> 00:45:43,440
I got an operation here,
corresponding to theta v

901
00:45:43,440 --> 00:45:47,670
inserts into the priority queue.

902
00:45:47,670 --> 00:45:53,760

903
00:45:53,760 --> 00:45:57,440
And that's inserting
things into Q.

904
00:45:57,440 --> 00:46:02,860
I got theta v
extract-min operations.

905
00:46:02,860 --> 00:46:08,290

906
00:46:08,290 --> 00:46:11,070
I'm only going to delete a
vertex once, process of vertex

907
00:46:11,070 --> 00:46:12,160
once.

908
00:46:12,160 --> 00:46:15,780
And that's why I have
theta v extract operations.

909
00:46:15,780 --> 00:46:22,840
And I have theta e, what
decrease key or update

910
00:46:22,840 --> 00:46:29,690
key operations because
when I do, I relax here.

911
00:46:29,690 --> 00:46:32,220
I'm decreasing the key.

912
00:46:32,220 --> 00:46:34,719

913
00:46:34,719 --> 00:46:36,510
It's in particular,
it's not an update key.

914
00:46:36,510 --> 00:46:39,329
It happens to be a decrease
key, which is not a big deal.

915
00:46:39,329 --> 00:46:40,620
We don't need to get into that.

916
00:46:40,620 --> 00:46:42,530
But you are reducing
the d value.

917
00:46:42,530 --> 00:46:45,040
So it's a decrease
key operation.

918
00:46:45,040 --> 00:46:51,295
And, again, it's theta e
because, in a directed graph,

919
00:46:51,295 --> 00:46:53,170
you're only going to
process each edge that's

920
00:46:53,170 --> 00:46:55,512
coming out of the vertex once.

921
00:46:55,512 --> 00:46:57,220
Since you're processing
each vertex once,

922
00:46:57,220 --> 00:46:59,930
and you're looking at
all of the outgoing edges

923
00:46:59,930 --> 00:47:01,470
from that vertex.

924
00:47:01,470 --> 00:47:02,530
OK?

925
00:47:02,530 --> 00:47:06,340
So that's what you can get
looking at the pseudocode.

926
00:47:06,340 --> 00:47:09,230
And now, you're a data
structure designer.

927
00:47:09,230 --> 00:47:12,120
And you have some choices
here, with respect

928
00:47:12,120 --> 00:47:14,910
to actually implementing
the priority queue.

929
00:47:14,910 --> 00:47:21,030
And let's look at the complexity
of Dijkstra for arrays.

930
00:47:21,030 --> 00:47:25,420
So, suppose I ended
up using an array

931
00:47:25,420 --> 00:47:28,040
structure for the
priority queue.

932
00:47:28,040 --> 00:47:31,800
But then, what do I have?

933
00:47:31,800 --> 00:47:37,570
I have, if I look at
this, my extract-min, what

934
00:47:37,570 --> 00:47:40,720
is the complexity of
extract-min in an array?

935
00:47:40,720 --> 00:47:41,540
AUDIENCE: Theta v.

936
00:47:41,540 --> 00:47:44,270
PROFESSOR: Theta v. And
what's the complexity

937
00:47:44,270 --> 00:47:48,290
of a decrease key in an array?

938
00:47:48,290 --> 00:47:50,210
I just go access that element.

939
00:47:50,210 --> 00:47:51,600
And I change it.

940
00:47:51,600 --> 00:47:53,140
State of one, right?

941
00:47:53,140 --> 00:47:59,010
So I have theta v
for extract-min.

942
00:47:59,010 --> 00:48:00,810
I'll just call it ex-min.

943
00:48:00,810 --> 00:48:06,750
Theta one for decrease key.

944
00:48:06,750 --> 00:48:09,890
And if I go do the
multiplication,

945
00:48:09,890 --> 00:48:17,290
I get theta v times v plus
e times 1, or a constant,

946
00:48:17,290 --> 00:48:19,860
which is theta v squared.

947
00:48:19,860 --> 00:48:23,260
Because I know that
e is order v squared.

948
00:48:23,260 --> 00:48:23,760
Right?

949
00:48:23,760 --> 00:48:27,100
If I have a simple graph,
it may be a complete graph,

950
00:48:27,100 --> 00:48:29,460
but-- we talked
about this last time.

951
00:48:29,460 --> 00:48:31,810
e is, at most, v squared.

952
00:48:31,810 --> 00:48:34,445
So I can just call
this theta v squared.

953
00:48:34,445 --> 00:48:35,340
All right?

954
00:48:35,340 --> 00:48:39,000
So we have a theta v squared
Dijkstra implementation

955
00:48:39,000 --> 00:48:42,012
that uses an array structure.

956
00:48:42,012 --> 00:48:43,720
But do we want to use
an array structure?

957
00:48:43,720 --> 00:48:49,290
What data structure
should we use?

958
00:48:49,290 --> 00:48:50,200
Yeah?

959
00:48:50,200 --> 00:48:50,829
AUDIENCE: Heap.

960
00:48:50,829 --> 00:48:52,370
PROFESSOR: You can
use it a min-heap.

961
00:48:52,370 --> 00:48:53,990
Exactly right.

962
00:48:53,990 --> 00:49:00,840
So, if you use a
binary min-heap,

963
00:49:00,840 --> 00:49:16,830
then my extract-min is
finding the min is a constant

964
00:49:16,830 --> 00:49:18,910
because you just pick
it up from the top.

965
00:49:18,910 --> 00:49:22,770
But we know that, if you
want to update the heap,

966
00:49:22,770 --> 00:49:28,220
and delete it, then it's going
to take that theta log v.

967
00:49:28,220 --> 00:49:31,460
And decrease key
is the same thing.

968
00:49:31,460 --> 00:49:35,336
Theta log v. So that's
worse than array.

969
00:49:35,336 --> 00:49:37,880

970
00:49:37,880 --> 00:49:40,000
And if I go do the
multiplication again,

971
00:49:40,000 --> 00:49:45,920
I get v log v plus e log v. OK?

972
00:49:45,920 --> 00:49:49,590
And this is not quite the
complexity that I put up,

973
00:49:49,590 --> 00:49:54,330
as some of you may
remember, last time.

974
00:49:54,330 --> 00:49:57,790
This is not the optimum
complexity of Dijkstra.

975
00:49:57,790 --> 00:50:01,280
Or an optimal
complexity of Dijkstra.

976
00:50:01,280 --> 00:50:05,800
You can actually take this out
by using a data structure that

977
00:50:05,800 --> 00:50:08,460
we won't talk about in 006.

978
00:50:08,460 --> 00:50:11,190
But you can read about it.

979
00:50:11,190 --> 00:50:15,660
It's not 6006 level material.

980
00:50:15,660 --> 00:50:18,410
You're not responsible
for this in 006.

981
00:50:18,410 --> 00:50:20,480
But it's got a Fibonacci heap.

982
00:50:20,480 --> 00:50:22,780
And you might learn
about it in 6046.

983
00:50:22,780 --> 00:50:27,440
The Fibonacci heap is an
amortized data structure

984
00:50:27,440 --> 00:50:31,980
that has theta log
v for extract-min.

985
00:50:31,980 --> 00:50:43,090
And theta one amortized
time for decrease key.

986
00:50:43,090 --> 00:50:44,890
And what's nice
about it is that,

987
00:50:44,890 --> 00:50:52,320
once you do that, you end up
with theta v log v plus e time.

988
00:50:52,320 --> 00:50:56,850
And that's the complexity
I put up way back, I guess,

989
00:50:56,850 --> 00:50:59,610
last Thursday.

990
00:50:59,610 --> 00:51:04,000
So that's to show you, with
respect to two special cases,

991
00:51:04,000 --> 00:51:08,930
we have the DAGs, which are
linear time, essentially.

992
00:51:08,930 --> 00:51:13,420
And Dijkstra, with amortized,
and their proper data

993
00:51:13,420 --> 00:51:16,101
structure, also,
essentially, linear time.

994
00:51:16,101 --> 00:51:16,600
Right?

995
00:51:16,600 --> 00:51:18,308
Next time, we'll look
at the general case

996
00:51:18,308 --> 00:51:20,550
where we have potentially
negative cycles.

997
00:51:20,550 --> 00:51:24,070
And we end up with algorithms
that have greater complexity.

998
00:51:24,070 --> 00:51:26,220
See you next time.